package clojure.asm;
import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper;
import com.ochafik.lang.jnaerator.runtime.Structure;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.List;
/**
 * JNA Wrapper for library <b>clang</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClangLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("clang", true, ClangLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClangLibrary.JNA_LIBRARY_NAME, MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final ClangLibrary INSTANCE = (ClangLibrary)Native.loadLibrary(ClangLibrary.JNA_LIBRARY_NAME, ClangLibrary.class, MangledFunctionMapper.DEFAULT_OPTIONS);
	/**
	 * \brief Error codes returned by libclang routines.<br>
	 * Zero (\c CXError_Success) is the only error code indicating success.  Other<br>
	 * error codes, including not yet assigned non-zero values, indicate errors.<br>
	 * <i>native declaration : clang-c/CXErrorCode.h:12</i><br>
	 * enum values
	 */
	public static interface CXErrorCode {
		/** <i>native declaration : clang-c/CXErrorCode.h:16</i> */
		public static final int CXError_Success = 0;
		/** <i>native declaration : clang-c/CXErrorCode.h:24</i> */
		public static final int CXError_Failure = 1;
		/** <i>native declaration : clang-c/CXErrorCode.h:29</i> */
		public static final int CXError_Crashed = 2;
		/** <i>native declaration : clang-c/CXErrorCode.h:35</i> */
		public static final int CXError_InvalidArguments = 3;
		/** <i>native declaration : clang-c/CXErrorCode.h:40</i> */
		public static final int CXError_ASTReadError = 4;
	};
	/**
	 * \brief Describes the availability of a particular entity, which indicates<br>
	 * whether the use of this entity will result in a warning or error due to<br>
	 * it being deprecated or unavailable.<br>
	 * <i>native declaration : clang-c/Index.h:124</i><br>
	 * enum values
	 */
	public static interface CXAvailabilityKind {
		/** <i>native declaration : clang-c/Index.h:128</i> */
		public static final int CXAvailability_Available = 0;
		/** <i>native declaration : clang-c/Index.h:133</i> */
		public static final int CXAvailability_Deprecated = 1;
		/** <i>native declaration : clang-c/Index.h:137</i> */
		public static final int CXAvailability_NotAvailable = 2;
		/** <i>native declaration : clang-c/Index.h:142</i> */
		public static final int CXAvailability_NotAccessible = 3;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXGlobalOptFlags {
		/** <i>native declaration : clang-c/Index.h:223</i> */
		public static final int CXGlobalOpt_None = 0x0;
		/** <i>native declaration : clang-c/Index.h:232</i> */
		public static final int CXGlobalOpt_ThreadBackgroundPriorityForIndexing = 0x1;
		/** <i>native declaration : clang-c/Index.h:241</i> */
		public static final int CXGlobalOpt_ThreadBackgroundPriorityForEditing = 0x2;
		/** <i>native declaration : clang-c/Index.h:247</i> */
		public static final int CXGlobalOpt_ThreadBackgroundPriorityForAll = (int)ClangLibrary.CXGlobalOptFlags.CXGlobalOpt_ThreadBackgroundPriorityForIndexing | (int)ClangLibrary.CXGlobalOptFlags.CXGlobalOpt_ThreadBackgroundPriorityForEditing;
	};
	/**
	 * \brief Describes the severity of a particular diagnostic.<br>
	 * <i>native declaration : clang-c/Index.h:647</i><br>
	 * enum values
	 */
	public static interface CXDiagnosticSeverity {
		/** <i>native declaration : clang-c/Index.h:652</i> */
		public static final int CXDiagnostic_Ignored = 0;
		/** <i>native declaration : clang-c/Index.h:658</i> */
		public static final int CXDiagnostic_Note = 1;
		/** <i>native declaration : clang-c/Index.h:664</i> */
		public static final int CXDiagnostic_Warning = 2;
		/** <i>native declaration : clang-c/Index.h:669</i> */
		public static final int CXDiagnostic_Error = 3;
		/** <i>native declaration : clang-c/Index.h:676</i> */
		public static final int CXDiagnostic_Fatal = 4;
	};
	/**
	 * \brief Describes the kind of error that occurred (if any) in a call to<br>
	 * \c clang_loadDiagnostics.<br>
	 * <i>native declaration : clang-c/Index.h:712</i><br>
	 * enum values
	 */
	public static interface CXLoadDiag_Error {
		/** <i>native declaration : clang-c/Index.h:716</i> */
		public static final int CXLoadDiag_None = 0;
		/** <i>native declaration : clang-c/Index.h:722</i> */
		public static final int CXLoadDiag_Unknown = 1;
		/** <i>native declaration : clang-c/Index.h:728</i> */
		public static final int CXLoadDiag_CannotLoad = 2;
		/** <i>native declaration : clang-c/Index.h:734</i> */
		public static final int CXLoadDiag_InvalidFile = 3;
	};
	/**
	 * \brief Options to control the display of diagnostics.<br>
	 * The values in this enum are meant to be combined to customize the<br>
	 * behavior of \c clang_formatDiagnostic().<br>
	 * <i>native declaration : clang-c/Index.h:805</i><br>
	 * enum values
	 */
	public static interface CXDiagnosticDisplayOptions {
		/** <i>native declaration : clang-c/Index.h:819</i> */
		public static final int CXDiagnostic_DisplaySourceLocation = 0x01;
		/** <i>native declaration : clang-c/Index.h:827</i> */
		public static final int CXDiagnostic_DisplayColumn = 0x02;
		/** <i>native declaration : clang-c/Index.h:837</i> */
		public static final int CXDiagnostic_DisplaySourceRanges = 0x04;
		/** <i>native declaration : clang-c/Index.h:846</i> */
		public static final int CXDiagnostic_DisplayOption = 0x08;
		/** <i>native declaration : clang-c/Index.h:855</i> */
		public static final int CXDiagnostic_DisplayCategoryId = 0x10;
		/** <i>native declaration : clang-c/Index.h:864</i> */
		public static final int CXDiagnostic_DisplayCategoryName = 0x20;
	};
	/**
	 * \brief Flags that control the creation of translation units.<br>
	 * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * constructing the translation unit.<br>
	 * <i>native declaration : clang-c/Index.h:1115</i><br>
	 * enum values
	 */
	public static interface CXTranslationUnit_Flags {
		/** <i>native declaration : clang-c/Index.h:1120</i> */
		public static final int CXTranslationUnit_None = 0x0;
		/** <i>native declaration : clang-c/Index.h:1132</i> */
		public static final int CXTranslationUnit_DetailedPreprocessingRecord = 0x01;
		/** <i>native declaration : clang-c/Index.h:1145</i> */
		public static final int CXTranslationUnit_Incomplete = 0x02;
		/** <i>native declaration : clang-c/Index.h:1161</i> */
		public static final int CXTranslationUnit_PrecompiledPreamble = 0x04;
		/** <i>native declaration : clang-c/Index.h:1171</i> */
		public static final int CXTranslationUnit_CacheCompletionResults = 0x08;
		/** <i>native declaration : clang-c/Index.h:1180</i> */
		public static final int CXTranslationUnit_ForSerialization = 0x10;
		/** <i>native declaration : clang-c/Index.h:1188</i> */
		public static final int CXTranslationUnit_CXXChainedPCH = 0x20;
		/** <i>native declaration : clang-c/Index.h:1197</i> */
		public static final int CXTranslationUnit_SkipFunctionBodies = 0x40;
		/** <i>native declaration : clang-c/Index.h:1204</i> */
		public static final int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 0x80;
	};
	/**
	 * \brief Flags that control how translation units are saved.<br>
	 * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * saving the translation unit.<br>
	 * <i>native declaration : clang-c/Index.h:1297</i><br>
	 * enum values
	 */
	public static interface CXSaveTranslationUnit_Flags {
		/** <i>native declaration : clang-c/Index.h:1301</i> */
		public static final int CXSaveTranslationUnit_None = 0x0;
	};
	/**
	 * \brief Describes the kind of error that occurred (if any) in a call to<br>
	 * \c clang_saveTranslationUnit().<br>
	 * <i>native declaration : clang-c/Index.h:1319</i><br>
	 * enum values
	 */
	public static interface CXSaveError {
		/** <i>native declaration : clang-c/Index.h:1323</i> */
		public static final int CXSaveError_None = 0;
		/** <i>native declaration : clang-c/Index.h:1332</i> */
		public static final int CXSaveError_Unknown = 1;
		/** <i>native declaration : clang-c/Index.h:1341</i> */
		public static final int CXSaveError_TranslationErrors = 2;
		/** <i>native declaration : clang-c/Index.h:1347</i> */
		public static final int CXSaveError_InvalidTU = 3;
	};
	/**
	 * \brief Flags that control the reparsing of translation units.<br>
	 * The enumerators in this enumeration type are meant to be bitwise<br>
	 * ORed together to specify which options should be used when<br>
	 * reparsing the translation unit.<br>
	 * <i>native declaration : clang-c/Index.h:1389</i><br>
	 * enum values
	 */
	public static interface CXReparse_Flags {
		/** <i>native declaration : clang-c/Index.h:1393</i> */
		public static final int CXReparse_None = 0x0;
	};
	/**
	 * \brief Categorizes how memory is being used by a translation unit.<br>
	 * <i>native declaration : clang-c/Index.h:1455</i><br>
	 * enum values
	 */
	public static interface CXTUResourceUsageKind {
		/** <i>native declaration : clang-c/Index.h:1456</i> */
		public static final int CXTUResourceUsage_AST = 1;
		/** <i>native declaration : clang-c/Index.h:1457</i> */
		public static final int CXTUResourceUsage_Identifiers = 2;
		/** <i>native declaration : clang-c/Index.h:1458</i> */
		public static final int CXTUResourceUsage_Selectors = 3;
		/** <i>native declaration : clang-c/Index.h:1459</i> */
		public static final int CXTUResourceUsage_GlobalCompletionResults = 4;
		/** <i>native declaration : clang-c/Index.h:1460</i> */
		public static final int CXTUResourceUsage_SourceManagerContentCache = 5;
		/** <i>native declaration : clang-c/Index.h:1461</i> */
		public static final int CXTUResourceUsage_AST_SideTables = 6;
		/** <i>native declaration : clang-c/Index.h:1462</i> */
		public static final int CXTUResourceUsage_SourceManager_Membuffer_Malloc = 7;
		/** <i>native declaration : clang-c/Index.h:1463</i> */
		public static final int CXTUResourceUsage_SourceManager_Membuffer_MMap = 8;
		/** <i>native declaration : clang-c/Index.h:1464</i> */
		public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = 9;
		/** <i>native declaration : clang-c/Index.h:1465</i> */
		public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = 10;
		/** <i>native declaration : clang-c/Index.h:1466</i> */
		public static final int CXTUResourceUsage_Preprocessor = 11;
		/** <i>native declaration : clang-c/Index.h:1467</i> */
		public static final int CXTUResourceUsage_PreprocessingRecord = 12;
		/** <i>native declaration : clang-c/Index.h:1468</i> */
		public static final int CXTUResourceUsage_SourceManager_DataStructures = 13;
		/** <i>native declaration : clang-c/Index.h:1469</i> */
		public static final int CXTUResourceUsage_Preprocessor_HeaderSearch = 14;
		/** <i>native declaration : clang-c/Index.h:1470</i> */
		public static final int CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = (int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_AST;
		/** <i>native declaration : clang-c/Index.h:1471</i> */
		public static final int CXTUResourceUsage_MEMORY_IN_BYTES_END = (int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_Preprocessor_HeaderSearch;
		/** <i>native declaration : clang-c/Index.h:1474</i> */
		public static final int CXTUResourceUsage_First = (int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_AST;
		/** <i>native declaration : clang-c/Index.h:1475</i> */
		public static final int CXTUResourceUsage_Last = (int)ClangLibrary.CXTUResourceUsageKind.CXTUResourceUsage_Preprocessor_HeaderSearch;
	};
	/**
	 * \brief Describes the kind of entity that a cursor refers to.<br>
	 * <i>native declaration : clang-c/Index.h:1524</i><br>
	 * enum values
	 */
	public static interface CXCursorKind {
		/** <i>native declaration : clang-c/Index.h:1535</i> */
		public static final int CXCursor_UnexposedDecl = 1;
		/** <i>native declaration : clang-c/Index.h:1537</i> */
		public static final int CXCursor_StructDecl = 2;
		/** <i>native declaration : clang-c/Index.h:1539</i> */
		public static final int CXCursor_UnionDecl = 3;
		/** <i>native declaration : clang-c/Index.h:1541</i> */
		public static final int CXCursor_ClassDecl = 4;
		/** <i>native declaration : clang-c/Index.h:1543</i> */
		public static final int CXCursor_EnumDecl = 5;
		/** <i>native declaration : clang-c/Index.h:1548</i> */
		public static final int CXCursor_FieldDecl = 6;
		/** <i>native declaration : clang-c/Index.h:1550</i> */
		public static final int CXCursor_EnumConstantDecl = 7;
		/** <i>native declaration : clang-c/Index.h:1552</i> */
		public static final int CXCursor_FunctionDecl = 8;
		/** <i>native declaration : clang-c/Index.h:1554</i> */
		public static final int CXCursor_VarDecl = 9;
		/** <i>native declaration : clang-c/Index.h:1556</i> */
		public static final int CXCursor_ParmDecl = 10;
		/** <i>native declaration : clang-c/Index.h:1558</i> */
		public static final int CXCursor_ObjCInterfaceDecl = 11;
		/** <i>native declaration : clang-c/Index.h:1560</i> */
		public static final int CXCursor_ObjCCategoryDecl = 12;
		/** <i>native declaration : clang-c/Index.h:1562</i> */
		public static final int CXCursor_ObjCProtocolDecl = 13;
		/** <i>native declaration : clang-c/Index.h:1564</i> */
		public static final int CXCursor_ObjCPropertyDecl = 14;
		/** <i>native declaration : clang-c/Index.h:1566</i> */
		public static final int CXCursor_ObjCIvarDecl = 15;
		/** <i>native declaration : clang-c/Index.h:1568</i> */
		public static final int CXCursor_ObjCInstanceMethodDecl = 16;
		/** <i>native declaration : clang-c/Index.h:1570</i> */
		public static final int CXCursor_ObjCClassMethodDecl = 17;
		/** <i>native declaration : clang-c/Index.h:1572</i> */
		public static final int CXCursor_ObjCImplementationDecl = 18;
		/** <i>native declaration : clang-c/Index.h:1574</i> */
		public static final int CXCursor_ObjCCategoryImplDecl = 19;
		/** <i>native declaration : clang-c/Index.h:1576</i> */
		public static final int CXCursor_TypedefDecl = 20;
		/** <i>native declaration : clang-c/Index.h:1578</i> */
		public static final int CXCursor_CXXMethod = 21;
		/** <i>native declaration : clang-c/Index.h:1580</i> */
		public static final int CXCursor_Namespace = 22;
		/** <i>native declaration : clang-c/Index.h:1582</i> */
		public static final int CXCursor_LinkageSpec = 23;
		/** <i>native declaration : clang-c/Index.h:1584</i> */
		public static final int CXCursor_Constructor = 24;
		/** <i>native declaration : clang-c/Index.h:1586</i> */
		public static final int CXCursor_Destructor = 25;
		/** <i>native declaration : clang-c/Index.h:1588</i> */
		public static final int CXCursor_ConversionFunction = 26;
		/** <i>native declaration : clang-c/Index.h:1590</i> */
		public static final int CXCursor_TemplateTypeParameter = 27;
		/** <i>native declaration : clang-c/Index.h:1592</i> */
		public static final int CXCursor_NonTypeTemplateParameter = 28;
		/** <i>native declaration : clang-c/Index.h:1594</i> */
		public static final int CXCursor_TemplateTemplateParameter = 29;
		/** <i>native declaration : clang-c/Index.h:1596</i> */
		public static final int CXCursor_FunctionTemplate = 30;
		/** <i>native declaration : clang-c/Index.h:1598</i> */
		public static final int CXCursor_ClassTemplate = 31;
		/** <i>native declaration : clang-c/Index.h:1600</i> */
		public static final int CXCursor_ClassTemplatePartialSpecialization = 32;
		/** <i>native declaration : clang-c/Index.h:1602</i> */
		public static final int CXCursor_NamespaceAlias = 33;
		/** <i>native declaration : clang-c/Index.h:1604</i> */
		public static final int CXCursor_UsingDirective = 34;
		/** <i>native declaration : clang-c/Index.h:1606</i> */
		public static final int CXCursor_UsingDeclaration = 35;
		/** <i>native declaration : clang-c/Index.h:1608</i> */
		public static final int CXCursor_TypeAliasDecl = 36;
		/** <i>native declaration : clang-c/Index.h:1610</i> */
		public static final int CXCursor_ObjCSynthesizeDecl = 37;
		/** <i>native declaration : clang-c/Index.h:1612</i> */
		public static final int CXCursor_ObjCDynamicDecl = 38;
		/** <i>native declaration : clang-c/Index.h:1614</i> */
		public static final int CXCursor_CXXAccessSpecifier = 39;
		/** <i>native declaration : clang-c/Index.h:1616</i> */
		public static final int CXCursor_FirstDecl = (int)ClangLibrary.CXCursorKind.CXCursor_UnexposedDecl;
		/** <i>native declaration : clang-c/Index.h:1617</i> */
		public static final int CXCursor_LastDecl = (int)ClangLibrary.CXCursorKind.CXCursor_CXXAccessSpecifier;
		/**
		 * Decl references<br>
		 * <i>native declaration : clang-c/Index.h:1620</i>
		 */
		public static final int CXCursor_FirstRef = 40;
		/** <i>native declaration : clang-c/Index.h:1621</i> */
		public static final int CXCursor_ObjCSuperClassRef = 40;
		/** <i>native declaration : clang-c/Index.h:1622</i> */
		public static final int CXCursor_ObjCProtocolRef = 41;
		/** <i>native declaration : clang-c/Index.h:1623</i> */
		public static final int CXCursor_ObjCClassRef = 42;
		/** <i>native declaration : clang-c/Index.h:1639</i> */
		public static final int CXCursor_TypeRef = 43;
		/** <i>native declaration : clang-c/Index.h:1640</i> */
		public static final int CXCursor_CXXBaseSpecifier = 44;
		/** <i>native declaration : clang-c/Index.h:1645</i> */
		public static final int CXCursor_TemplateRef = 45;
		/** <i>native declaration : clang-c/Index.h:1649</i> */
		public static final int CXCursor_NamespaceRef = 46;
		/** <i>native declaration : clang-c/Index.h:1654</i> */
		public static final int CXCursor_MemberRef = 47;
		/** <i>native declaration : clang-c/Index.h:1670</i> */
		public static final int CXCursor_LabelRef = 48;
		/** <i>native declaration : clang-c/Index.h:1708</i> */
		public static final int CXCursor_OverloadedDeclRef = 49;
		/** <i>native declaration : clang-c/Index.h:1714</i> */
		public static final int CXCursor_VariableRef = 50;
		/** <i>native declaration : clang-c/Index.h:1716</i> */
		public static final int CXCursor_LastRef = (int)ClangLibrary.CXCursorKind.CXCursor_VariableRef;
		/** <i>native declaration : clang-c/Index.h:1719</i> */
		public static final int CXCursor_FirstInvalid = 70;
		/** <i>native declaration : clang-c/Index.h:1720</i> */
		public static final int CXCursor_InvalidFile = 70;
		/** <i>native declaration : clang-c/Index.h:1721</i> */
		public static final int CXCursor_NoDeclFound = 71;
		/** <i>native declaration : clang-c/Index.h:1722</i> */
		public static final int CXCursor_NotImplemented = 72;
		/** <i>native declaration : clang-c/Index.h:1723</i> */
		public static final int CXCursor_InvalidCode = 73;
		/** <i>native declaration : clang-c/Index.h:1724</i> */
		public static final int CXCursor_LastInvalid = (int)ClangLibrary.CXCursorKind.CXCursor_InvalidCode;
		/** <i>native declaration : clang-c/Index.h:1727</i> */
		public static final int CXCursor_FirstExpr = 100;
		/** <i>native declaration : clang-c/Index.h:1738</i> */
		public static final int CXCursor_UnexposedExpr = 100;
		/** <i>native declaration : clang-c/Index.h:1744</i> */
		public static final int CXCursor_DeclRefExpr = 101;
		/** <i>native declaration : clang-c/Index.h:1750</i> */
		public static final int CXCursor_MemberRefExpr = 102;
		/** <i>native declaration : clang-c/Index.h:1753</i> */
		public static final int CXCursor_CallExpr = 103;
		/** <i>native declaration : clang-c/Index.h:1757</i> */
		public static final int CXCursor_ObjCMessageExpr = 104;
		/** <i>native declaration : clang-c/Index.h:1760</i> */
		public static final int CXCursor_BlockExpr = 105;
		/** <i>native declaration : clang-c/Index.h:1764</i> */
		public static final int CXCursor_IntegerLiteral = 106;
		/** <i>native declaration : clang-c/Index.h:1768</i> */
		public static final int CXCursor_FloatingLiteral = 107;
		/** <i>native declaration : clang-c/Index.h:1772</i> */
		public static final int CXCursor_ImaginaryLiteral = 108;
		/** <i>native declaration : clang-c/Index.h:1776</i> */
		public static final int CXCursor_StringLiteral = 109;
		/** <i>native declaration : clang-c/Index.h:1780</i> */
		public static final int CXCursor_CharacterLiteral = 110;
		/** <i>native declaration : clang-c/Index.h:1786</i> */
		public static final int CXCursor_ParenExpr = 111;
		/** <i>native declaration : clang-c/Index.h:1791</i> */
		public static final int CXCursor_UnaryOperator = 112;
		/** <i>native declaration : clang-c/Index.h:1795</i> */
		public static final int CXCursor_ArraySubscriptExpr = 113;
		/** <i>native declaration : clang-c/Index.h:1800</i> */
		public static final int CXCursor_BinaryOperator = 114;
		/** <i>native declaration : clang-c/Index.h:1804</i> */
		public static final int CXCursor_CompoundAssignOperator = 115;
		/** <i>native declaration : clang-c/Index.h:1808</i> */
		public static final int CXCursor_ConditionalOperator = 116;
		/** <i>native declaration : clang-c/Index.h:1815</i> */
		public static final int CXCursor_CStyleCastExpr = 117;
		/** <i>native declaration : clang-c/Index.h:1819</i> */
		public static final int CXCursor_CompoundLiteralExpr = 118;
		/** <i>native declaration : clang-c/Index.h:1823</i> */
		public static final int CXCursor_InitListExpr = 119;
		/** <i>native declaration : clang-c/Index.h:1827</i> */
		public static final int CXCursor_AddrLabelExpr = 120;
		/** <i>native declaration : clang-c/Index.h:1831</i> */
		public static final int CXCursor_StmtExpr = 121;
		/** <i>native declaration : clang-c/Index.h:1835</i> */
		public static final int CXCursor_GenericSelectionExpr = 122;
		/** <i>native declaration : clang-c/Index.h:1845</i> */
		public static final int CXCursor_GNUNullExpr = 123;
		/** <i>native declaration : clang-c/Index.h:1849</i> */
		public static final int CXCursor_CXXStaticCastExpr = 124;
		/** <i>native declaration : clang-c/Index.h:1853</i> */
		public static final int CXCursor_CXXDynamicCastExpr = 125;
		/** <i>native declaration : clang-c/Index.h:1857</i> */
		public static final int CXCursor_CXXReinterpretCastExpr = 126;
		/** <i>native declaration : clang-c/Index.h:1861</i> */
		public static final int CXCursor_CXXConstCastExpr = 127;
		/** <i>native declaration : clang-c/Index.h:1871</i> */
		public static final int CXCursor_CXXFunctionalCastExpr = 128;
		/** <i>native declaration : clang-c/Index.h:1875</i> */
		public static final int CXCursor_CXXTypeidExpr = 129;
		/** <i>native declaration : clang-c/Index.h:1879</i> */
		public static final int CXCursor_CXXBoolLiteralExpr = 130;
		/** <i>native declaration : clang-c/Index.h:1883</i> */
		public static final int CXCursor_CXXNullPtrLiteralExpr = 131;
		/** <i>native declaration : clang-c/Index.h:1887</i> */
		public static final int CXCursor_CXXThisExpr = 132;
		/** <i>native declaration : clang-c/Index.h:1894</i> */
		public static final int CXCursor_CXXThrowExpr = 133;
		/** <i>native declaration : clang-c/Index.h:1899</i> */
		public static final int CXCursor_CXXNewExpr = 134;
		/** <i>native declaration : clang-c/Index.h:1904</i> */
		public static final int CXCursor_CXXDeleteExpr = 135;
		/** <i>native declaration : clang-c/Index.h:1908</i> */
		public static final int CXCursor_UnaryExpr = 136;
		/** <i>native declaration : clang-c/Index.h:1912</i> */
		public static final int CXCursor_ObjCStringLiteral = 137;
		/** <i>native declaration : clang-c/Index.h:1916</i> */
		public static final int CXCursor_ObjCEncodeExpr = 138;
		/** <i>native declaration : clang-c/Index.h:1920</i> */
		public static final int CXCursor_ObjCSelectorExpr = 139;
		/** <i>native declaration : clang-c/Index.h:1924</i> */
		public static final int CXCursor_ObjCProtocolExpr = 140;
		/** <i>native declaration : clang-c/Index.h:1933</i> */
		public static final int CXCursor_ObjCBridgedCastExpr = 141;
		/** <i>native declaration : clang-c/Index.h:1948</i> */
		public static final int CXCursor_PackExpansionExpr = 142;
		/** <i>native declaration : clang-c/Index.h:1960</i> */
		public static final int CXCursor_SizeOfPackExpr = 143;
		/** <i>native declaration : clang-c/Index.h:1974</i> */
		public static final int CXCursor_LambdaExpr = 144;
		/** <i>native declaration : clang-c/Index.h:1978</i> */
		public static final int CXCursor_ObjCBoolLiteralExpr = 145;
		/** <i>native declaration : clang-c/Index.h:1982</i> */
		public static final int CXCursor_ObjCSelfExpr = 146;
		/** <i>native declaration : clang-c/Index.h:1984</i> */
		public static final int CXCursor_LastExpr = (int)ClangLibrary.CXCursorKind.CXCursor_ObjCSelfExpr;
		/** <i>native declaration : clang-c/Index.h:1987</i> */
		public static final int CXCursor_FirstStmt = 200;
		/** <i>native declaration : clang-c/Index.h:1997</i> */
		public static final int CXCursor_UnexposedStmt = 200;
		/** <i>native declaration : clang-c/Index.h:2010</i> */
		public static final int CXCursor_LabelStmt = 201;
		/** <i>native declaration : clang-c/Index.h:2017</i> */
		public static final int CXCursor_CompoundStmt = 202;
		/** <i>native declaration : clang-c/Index.h:2021</i> */
		public static final int CXCursor_CaseStmt = 203;
		/** <i>native declaration : clang-c/Index.h:2025</i> */
		public static final int CXCursor_DefaultStmt = 204;
		/** <i>native declaration : clang-c/Index.h:2029</i> */
		public static final int CXCursor_IfStmt = 205;
		/** <i>native declaration : clang-c/Index.h:2033</i> */
		public static final int CXCursor_SwitchStmt = 206;
		/** <i>native declaration : clang-c/Index.h:2037</i> */
		public static final int CXCursor_WhileStmt = 207;
		/** <i>native declaration : clang-c/Index.h:2041</i> */
		public static final int CXCursor_DoStmt = 208;
		/** <i>native declaration : clang-c/Index.h:2045</i> */
		public static final int CXCursor_ForStmt = 209;
		/** <i>native declaration : clang-c/Index.h:2049</i> */
		public static final int CXCursor_GotoStmt = 210;
		/** <i>native declaration : clang-c/Index.h:2053</i> */
		public static final int CXCursor_IndirectGotoStmt = 211;
		/** <i>native declaration : clang-c/Index.h:2057</i> */
		public static final int CXCursor_ContinueStmt = 212;
		/** <i>native declaration : clang-c/Index.h:2061</i> */
		public static final int CXCursor_BreakStmt = 213;
		/** <i>native declaration : clang-c/Index.h:2065</i> */
		public static final int CXCursor_ReturnStmt = 214;
		/** <i>native declaration : clang-c/Index.h:2069</i> */
		public static final int CXCursor_GCCAsmStmt = 215;
		/** <i>native declaration : clang-c/Index.h:2070</i> */
		public static final int CXCursor_AsmStmt = (int)ClangLibrary.CXCursorKind.CXCursor_GCCAsmStmt;
		/** <i>native declaration : clang-c/Index.h:2074</i> */
		public static final int CXCursor_ObjCAtTryStmt = 216;
		/** <i>native declaration : clang-c/Index.h:2078</i> */
		public static final int CXCursor_ObjCAtCatchStmt = 217;
		/** <i>native declaration : clang-c/Index.h:2082</i> */
		public static final int CXCursor_ObjCAtFinallyStmt = 218;
		/** <i>native declaration : clang-c/Index.h:2086</i> */
		public static final int CXCursor_ObjCAtThrowStmt = 219;
		/** <i>native declaration : clang-c/Index.h:2090</i> */
		public static final int CXCursor_ObjCAtSynchronizedStmt = 220;
		/** <i>native declaration : clang-c/Index.h:2094</i> */
		public static final int CXCursor_ObjCAutoreleasePoolStmt = 221;
		/** <i>native declaration : clang-c/Index.h:2098</i> */
		public static final int CXCursor_ObjCForCollectionStmt = 222;
		/** <i>native declaration : clang-c/Index.h:2102</i> */
		public static final int CXCursor_CXXCatchStmt = 223;
		/** <i>native declaration : clang-c/Index.h:2106</i> */
		public static final int CXCursor_CXXTryStmt = 224;
		/** <i>native declaration : clang-c/Index.h:2110</i> */
		public static final int CXCursor_CXXForRangeStmt = 225;
		/** <i>native declaration : clang-c/Index.h:2114</i> */
		public static final int CXCursor_SEHTryStmt = 226;
		/** <i>native declaration : clang-c/Index.h:2118</i> */
		public static final int CXCursor_SEHExceptStmt = 227;
		/** <i>native declaration : clang-c/Index.h:2122</i> */
		public static final int CXCursor_SEHFinallyStmt = 228;
		/** <i>native declaration : clang-c/Index.h:2126</i> */
		public static final int CXCursor_MSAsmStmt = 229;
		/** <i>native declaration : clang-c/Index.h:2132</i> */
		public static final int CXCursor_NullStmt = 230;
		/** <i>native declaration : clang-c/Index.h:2137</i> */
		public static final int CXCursor_DeclStmt = 231;
		/** <i>native declaration : clang-c/Index.h:2141</i> */
		public static final int CXCursor_OMPParallelDirective = 232;
		/** <i>native declaration : clang-c/Index.h:2145</i> */
		public static final int CXCursor_OMPSimdDirective = 233;
		/** <i>native declaration : clang-c/Index.h:2149</i> */
		public static final int CXCursor_OMPForDirective = 234;
		/** <i>native declaration : clang-c/Index.h:2153</i> */
		public static final int CXCursor_OMPSectionsDirective = 235;
		/** <i>native declaration : clang-c/Index.h:2157</i> */
		public static final int CXCursor_OMPSectionDirective = 236;
		/** <i>native declaration : clang-c/Index.h:2161</i> */
		public static final int CXCursor_OMPSingleDirective = 237;
		/** <i>native declaration : clang-c/Index.h:2165</i> */
		public static final int CXCursor_OMPParallelForDirective = 238;
		/** <i>native declaration : clang-c/Index.h:2169</i> */
		public static final int CXCursor_OMPParallelSectionsDirective = 239;
		/** <i>native declaration : clang-c/Index.h:2173</i> */
		public static final int CXCursor_OMPTaskDirective = 240;
		/** <i>native declaration : clang-c/Index.h:2177</i> */
		public static final int CXCursor_OMPMasterDirective = 241;
		/** <i>native declaration : clang-c/Index.h:2181</i> */
		public static final int CXCursor_OMPCriticalDirective = 242;
		/** <i>native declaration : clang-c/Index.h:2185</i> */
		public static final int CXCursor_OMPTaskyieldDirective = 243;
		/** <i>native declaration : clang-c/Index.h:2189</i> */
		public static final int CXCursor_OMPBarrierDirective = 244;
		/** <i>native declaration : clang-c/Index.h:2193</i> */
		public static final int CXCursor_OMPTaskwaitDirective = 245;
		/** <i>native declaration : clang-c/Index.h:2197</i> */
		public static final int CXCursor_OMPFlushDirective = 246;
		/** <i>native declaration : clang-c/Index.h:2201</i> */
		public static final int CXCursor_SEHLeaveStmt = 247;
		/** <i>native declaration : clang-c/Index.h:2205</i> */
		public static final int CXCursor_OMPOrderedDirective = 248;
		/** <i>native declaration : clang-c/Index.h:2209</i> */
		public static final int CXCursor_OMPAtomicDirective = 249;
		/** <i>native declaration : clang-c/Index.h:2211</i> */
		public static final int CXCursor_LastStmt = (int)ClangLibrary.CXCursorKind.CXCursor_OMPAtomicDirective;
		/** <i>native declaration : clang-c/Index.h:2219</i> */
		public static final int CXCursor_TranslationUnit = 300;
		/** <i>native declaration : clang-c/Index.h:2222</i> */
		public static final int CXCursor_FirstAttr = 400;
		/** <i>native declaration : clang-c/Index.h:2227</i> */
		public static final int CXCursor_UnexposedAttr = 400;
		/** <i>native declaration : clang-c/Index.h:2229</i> */
		public static final int CXCursor_IBActionAttr = 401;
		/** <i>native declaration : clang-c/Index.h:2230</i> */
		public static final int CXCursor_IBOutletAttr = 402;
		/** <i>native declaration : clang-c/Index.h:2231</i> */
		public static final int CXCursor_IBOutletCollectionAttr = 403;
		/** <i>native declaration : clang-c/Index.h:2232</i> */
		public static final int CXCursor_CXXFinalAttr = 404;
		/** <i>native declaration : clang-c/Index.h:2233</i> */
		public static final int CXCursor_CXXOverrideAttr = 405;
		/** <i>native declaration : clang-c/Index.h:2234</i> */
		public static final int CXCursor_AnnotateAttr = 406;
		/** <i>native declaration : clang-c/Index.h:2235</i> */
		public static final int CXCursor_AsmLabelAttr = 407;
		/** <i>native declaration : clang-c/Index.h:2236</i> */
		public static final int CXCursor_PackedAttr = 408;
		/** <i>native declaration : clang-c/Index.h:2237</i> */
		public static final int CXCursor_PureAttr = 409;
		/** <i>native declaration : clang-c/Index.h:2238</i> */
		public static final int CXCursor_ConstAttr = 410;
		/** <i>native declaration : clang-c/Index.h:2239</i> */
		public static final int CXCursor_NoDuplicateAttr = 411;
		/** <i>native declaration : clang-c/Index.h:2240</i> */
		public static final int CXCursor_CUDAConstantAttr = 412;
		/** <i>native declaration : clang-c/Index.h:2241</i> */
		public static final int CXCursor_CUDADeviceAttr = 413;
		/** <i>native declaration : clang-c/Index.h:2242</i> */
		public static final int CXCursor_CUDAGlobalAttr = 414;
		/** <i>native declaration : clang-c/Index.h:2243</i> */
		public static final int CXCursor_CUDAHostAttr = 415;
		/** <i>native declaration : clang-c/Index.h:2244</i> */
		public static final int CXCursor_CUDASharedAttr = 416;
		/** <i>native declaration : clang-c/Index.h:2245</i> */
		public static final int CXCursor_LastAttr = (int)ClangLibrary.CXCursorKind.CXCursor_CUDASharedAttr;
		/** <i>native declaration : clang-c/Index.h:2248</i> */
		public static final int CXCursor_PreprocessingDirective = 500;
		/** <i>native declaration : clang-c/Index.h:2249</i> */
		public static final int CXCursor_MacroDefinition = 501;
		/** <i>native declaration : clang-c/Index.h:2250</i> */
		public static final int CXCursor_MacroExpansion = 502;
		/** <i>native declaration : clang-c/Index.h:2251</i> */
		public static final int CXCursor_MacroInstantiation = (int)ClangLibrary.CXCursorKind.CXCursor_MacroExpansion;
		/** <i>native declaration : clang-c/Index.h:2252</i> */
		public static final int CXCursor_InclusionDirective = 503;
		/** <i>native declaration : clang-c/Index.h:2253</i> */
		public static final int CXCursor_FirstPreprocessing = (int)ClangLibrary.CXCursorKind.CXCursor_PreprocessingDirective;
		/** <i>native declaration : clang-c/Index.h:2254</i> */
		public static final int CXCursor_LastPreprocessing = (int)ClangLibrary.CXCursorKind.CXCursor_InclusionDirective;
		/** <i>native declaration : clang-c/Index.h:2260</i> */
		public static final int CXCursor_ModuleImportDecl = 600;
		/** <i>native declaration : clang-c/Index.h:2261</i> */
		public static final int CXCursor_FirstExtraDecl = (int)ClangLibrary.CXCursorKind.CXCursor_ModuleImportDecl;
		/** <i>native declaration : clang-c/Index.h:2262</i> */
		public static final int CXCursor_LastExtraDecl = (int)ClangLibrary.CXCursorKind.CXCursor_ModuleImportDecl;
	};
	/**
	 * \brief Describe the linkage of the entity referred to by a cursor.<br>
	 * <i>native declaration : clang-c/Index.h:2385</i><br>
	 * enum values
	 */
	public static interface CXLinkageKind {
		/** <i>native declaration : clang-c/Index.h:2388</i> */
		public static final int CXLinkage_Invalid = 0;
		/** <i>native declaration : clang-c/Index.h:2393</i> */
		public static final int CXLinkage_NoLinkage = 1;
		/** <i>native declaration : clang-c/Index.h:2395</i> */
		public static final int CXLinkage_Internal = 2;
		/** <i>native declaration : clang-c/Index.h:2398</i> */
		public static final int CXLinkage_UniqueExternal = 3;
		/** <i>native declaration : clang-c/Index.h:2400</i> */
		public static final int CXLinkage_External = 4;
	};
	/**
	 * \brief Describe the "language" of the entity referred to by a cursor.<br>
	 * <i>native declaration : clang-c/Index.h:2510</i><br>
	 * enum values
	 */
	public static interface CXLanguageKind {
		/** <i>native declaration : clang-c/Index.h:2511</i> */
		public static final int CXLanguage_Invalid = 0;
		/** <i>native declaration : clang-c/Index.h:2512</i> */
		public static final int CXLanguage_C = 1;
		/** <i>native declaration : clang-c/Index.h:2513</i> */
		public static final int CXLanguage_ObjC = 2;
		/** <i>native declaration : clang-c/Index.h:2514</i> */
		public static final int CXLanguage_CPlusPlus = 3;
	};
	/**
	 * \brief Describes the kind of type<br>
	 * <i>native declaration : clang-c/Index.h:2759</i><br>
	 * enum values
	 */
	public static interface CXTypeKind {
		/** <i>native declaration : clang-c/Index.h:2763</i> */
		public static final int CXType_Invalid = 0;
		/** <i>native declaration : clang-c/Index.h:2769</i> */
		public static final int CXType_Unexposed = 1;
		/** <i>native declaration : clang-c/Index.h:2772</i> */
		public static final int CXType_Void = 2;
		/** <i>native declaration : clang-c/Index.h:2773</i> */
		public static final int CXType_Bool = 3;
		/** <i>native declaration : clang-c/Index.h:2774</i> */
		public static final int CXType_Char_U = 4;
		/** <i>native declaration : clang-c/Index.h:2775</i> */
		public static final int CXType_UChar = 5;
		/** <i>native declaration : clang-c/Index.h:2776</i> */
		public static final int CXType_Char16 = 6;
		/** <i>native declaration : clang-c/Index.h:2777</i> */
		public static final int CXType_Char32 = 7;
		/** <i>native declaration : clang-c/Index.h:2778</i> */
		public static final int CXType_UShort = 8;
		/** <i>native declaration : clang-c/Index.h:2779</i> */
		public static final int CXType_UInt = 9;
		/** <i>native declaration : clang-c/Index.h:2780</i> */
		public static final int CXType_ULong = 10;
		/** <i>native declaration : clang-c/Index.h:2781</i> */
		public static final int CXType_ULongLong = 11;
		/** <i>native declaration : clang-c/Index.h:2782</i> */
		public static final int CXType_UInt128 = 12;
		/** <i>native declaration : clang-c/Index.h:2783</i> */
		public static final int CXType_Char_S = 13;
		/** <i>native declaration : clang-c/Index.h:2784</i> */
		public static final int CXType_SChar = 14;
		/** <i>native declaration : clang-c/Index.h:2785</i> */
		public static final int CXType_WChar = 15;
		/** <i>native declaration : clang-c/Index.h:2786</i> */
		public static final int CXType_Short = 16;
		/** <i>native declaration : clang-c/Index.h:2787</i> */
		public static final int CXType_Int = 17;
		/** <i>native declaration : clang-c/Index.h:2788</i> */
		public static final int CXType_Long = 18;
		/** <i>native declaration : clang-c/Index.h:2789</i> */
		public static final int CXType_LongLong = 19;
		/** <i>native declaration : clang-c/Index.h:2790</i> */
		public static final int CXType_Int128 = 20;
		/** <i>native declaration : clang-c/Index.h:2791</i> */
		public static final int CXType_Float = 21;
		/** <i>native declaration : clang-c/Index.h:2792</i> */
		public static final int CXType_Double = 22;
		/** <i>native declaration : clang-c/Index.h:2793</i> */
		public static final int CXType_LongDouble = 23;
		/** <i>native declaration : clang-c/Index.h:2794</i> */
		public static final int CXType_NullPtr = 24;
		/** <i>native declaration : clang-c/Index.h:2795</i> */
		public static final int CXType_Overload = 25;
		/** <i>native declaration : clang-c/Index.h:2796</i> */
		public static final int CXType_Dependent = 26;
		/** <i>native declaration : clang-c/Index.h:2797</i> */
		public static final int CXType_ObjCId = 27;
		/** <i>native declaration : clang-c/Index.h:2798</i> */
		public static final int CXType_ObjCClass = 28;
		/** <i>native declaration : clang-c/Index.h:2799</i> */
		public static final int CXType_ObjCSel = 29;
		/** <i>native declaration : clang-c/Index.h:2800</i> */
		public static final int CXType_FirstBuiltin = (int)ClangLibrary.CXTypeKind.CXType_Void;
		/** <i>native declaration : clang-c/Index.h:2801</i> */
		public static final int CXType_LastBuiltin = (int)ClangLibrary.CXTypeKind.CXType_ObjCSel;
		/** <i>native declaration : clang-c/Index.h:2803</i> */
		public static final int CXType_Complex = 100;
		/** <i>native declaration : clang-c/Index.h:2804</i> */
		public static final int CXType_Pointer = 101;
		/** <i>native declaration : clang-c/Index.h:2805</i> */
		public static final int CXType_BlockPointer = 102;
		/** <i>native declaration : clang-c/Index.h:2806</i> */
		public static final int CXType_LValueReference = 103;
		/** <i>native declaration : clang-c/Index.h:2807</i> */
		public static final int CXType_RValueReference = 104;
		/** <i>native declaration : clang-c/Index.h:2808</i> */
		public static final int CXType_Record = 105;
		/** <i>native declaration : clang-c/Index.h:2809</i> */
		public static final int CXType_Enum = 106;
		/** <i>native declaration : clang-c/Index.h:2810</i> */
		public static final int CXType_Typedef = 107;
		/** <i>native declaration : clang-c/Index.h:2811</i> */
		public static final int CXType_ObjCInterface = 108;
		/** <i>native declaration : clang-c/Index.h:2812</i> */
		public static final int CXType_ObjCObjectPointer = 109;
		/** <i>native declaration : clang-c/Index.h:2813</i> */
		public static final int CXType_FunctionNoProto = 110;
		/** <i>native declaration : clang-c/Index.h:2814</i> */
		public static final int CXType_FunctionProto = 111;
		/** <i>native declaration : clang-c/Index.h:2815</i> */
		public static final int CXType_ConstantArray = 112;
		/** <i>native declaration : clang-c/Index.h:2816</i> */
		public static final int CXType_Vector = 113;
		/** <i>native declaration : clang-c/Index.h:2817</i> */
		public static final int CXType_IncompleteArray = 114;
		/** <i>native declaration : clang-c/Index.h:2818</i> */
		public static final int CXType_VariableArray = 115;
		/** <i>native declaration : clang-c/Index.h:2819</i> */
		public static final int CXType_DependentSizedArray = 116;
		/** <i>native declaration : clang-c/Index.h:2820</i> */
		public static final int CXType_MemberPointer = 117;
	};
	/**
	 * \brief Describes the calling convention of a function type<br>
	 * <i>native declaration : clang-c/Index.h:2826</i><br>
	 * enum values
	 */
	public static interface CXCallingConv {
		/** <i>native declaration : clang-c/Index.h:2827</i> */
		public static final int CXCallingConv_Default = 0;
		/** <i>native declaration : clang-c/Index.h:2828</i> */
		public static final int CXCallingConv_C = 1;
		/** <i>native declaration : clang-c/Index.h:2829</i> */
		public static final int CXCallingConv_X86StdCall = 2;
		/** <i>native declaration : clang-c/Index.h:2830</i> */
		public static final int CXCallingConv_X86FastCall = 3;
		/** <i>native declaration : clang-c/Index.h:2831</i> */
		public static final int CXCallingConv_X86ThisCall = 4;
		/** <i>native declaration : clang-c/Index.h:2832</i> */
		public static final int CXCallingConv_X86Pascal = 5;
		/** <i>native declaration : clang-c/Index.h:2833</i> */
		public static final int CXCallingConv_AAPCS = 6;
		/** <i>native declaration : clang-c/Index.h:2834</i> */
		public static final int CXCallingConv_AAPCS_VFP = 7;
		/** <i>native declaration : clang-c/Index.h:2835</i> */
		public static final int CXCallingConv_PnaclCall = 8;
		/** <i>native declaration : clang-c/Index.h:2836</i> */
		public static final int CXCallingConv_IntelOclBicc = 9;
		/** <i>native declaration : clang-c/Index.h:2837</i> */
		public static final int CXCallingConv_X86_64Win64 = 10;
		/** <i>native declaration : clang-c/Index.h:2838</i> */
		public static final int CXCallingConv_X86_64SysV = 11;
		/** <i>native declaration : clang-c/Index.h:2840</i> */
		public static final int CXCallingConv_Invalid = 100;
		/** <i>native declaration : clang-c/Index.h:2841</i> */
		public static final int CXCallingConv_Unexposed = 200;
	};
	/**
	 * \brief List the possible error codes for \c clang_Type_getSizeOf,<br>
	 *   \c clang_Type_getAlignOf, \c clang_Type_getOffsetOf and<br>
	 *   \c clang_Cursor_getOffsetOf.<br>
	 * A value of this enumeration type can be returned if the target type is not<br>
	 * a valid argument to sizeof, alignof or offsetof.<br>
	 * <i>native declaration : clang-c/Index.h:3073</i><br>
	 * enum values
	 */
	public static interface CXTypeLayoutError {
		/** <i>native declaration : clang-c/Index.h:3077</i> */
		public static final int CXTypeLayoutError_Invalid = -1;
		/** <i>native declaration : clang-c/Index.h:3081</i> */
		public static final int CXTypeLayoutError_Incomplete = -2;
		/** <i>native declaration : clang-c/Index.h:3085</i> */
		public static final int CXTypeLayoutError_Dependent = -3;
		/** <i>native declaration : clang-c/Index.h:3089</i> */
		public static final int CXTypeLayoutError_NotConstantSize = -4;
		/** <i>native declaration : clang-c/Index.h:3093</i> */
		public static final int CXTypeLayoutError_InvalidFieldName = -5;
	};
	/**
	 * <i>native declaration : clang-c/Index.h:3143</i><br>
	 * enum values
	 */
	public static interface CXRefQualifierKind {
		/** <i>native declaration : clang-c/Index.h:3145</i> */
		public static final int CXRefQualifier_None = 0;
		/** <i>native declaration : clang-c/Index.h:3147</i> */
		public static final int CXRefQualifier_LValue = 1;
		/** <i>native declaration : clang-c/Index.h:3149</i> */
		public static final int CXRefQualifier_RValue = 2;
	};
	/**
	 * \brief Represents the C++ access control level to a base class for a<br>
	 * cursor with kind CX_CXXBaseSpecifier.<br>
	 * <i>native declaration : clang-c/Index.h:3194</i><br>
	 * enum values
	 */
	public static interface CX_CXXAccessSpecifier {
		/** <i>native declaration : clang-c/Index.h:3195</i> */
		public static final int CX_CXXInvalidAccessSpecifier = 0;
		/** <i>native declaration : clang-c/Index.h:3196</i> */
		public static final int CX_CXXPublic = 1;
		/** <i>native declaration : clang-c/Index.h:3197</i> */
		public static final int CX_CXXProtected = 2;
		/** <i>native declaration : clang-c/Index.h:3198</i> */
		public static final int CX_CXXPrivate = 3;
	};
	/**
	 * \brief Describes how the traversal of the children of a particular<br>
	 * cursor should proceed after visiting a particular child cursor.<br>
	 * A value of this enumeration type should be returned by each<br>
	 * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.<br>
	 * <i>native declaration : clang-c/Index.h:3276</i><br>
	 * enum values
	 */
	public static interface CXChildVisitResult {
		/** <i>native declaration : clang-c/Index.h:3280</i> */
		public static final int CXChildVisit_Break = 0;
		/** <i>native declaration : clang-c/Index.h:3285</i> */
		public static final int CXChildVisit_Continue = 1;
		/** <i>native declaration : clang-c/Index.h:3290</i> */
		public static final int CXChildVisit_Recurse = 2;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXObjCPropertyAttrKind {
		/** <i>native declaration : clang-c/Index.h:3565</i> */
		public static final int CXObjCPropertyAttr_noattr = 0x00;
		/** <i>native declaration : clang-c/Index.h:3566</i> */
		public static final int CXObjCPropertyAttr_readonly = 0x01;
		/** <i>native declaration : clang-c/Index.h:3567</i> */
		public static final int CXObjCPropertyAttr_getter = 0x02;
		/** <i>native declaration : clang-c/Index.h:3568</i> */
		public static final int CXObjCPropertyAttr_assign = 0x04;
		/** <i>native declaration : clang-c/Index.h:3569</i> */
		public static final int CXObjCPropertyAttr_readwrite = 0x08;
		/** <i>native declaration : clang-c/Index.h:3570</i> */
		public static final int CXObjCPropertyAttr_retain = 0x10;
		/** <i>native declaration : clang-c/Index.h:3571</i> */
		public static final int CXObjCPropertyAttr_copy = 0x20;
		/** <i>native declaration : clang-c/Index.h:3572</i> */
		public static final int CXObjCPropertyAttr_nonatomic = 0x40;
		/** <i>native declaration : clang-c/Index.h:3573</i> */
		public static final int CXObjCPropertyAttr_setter = 0x80;
		/** <i>native declaration : clang-c/Index.h:3574</i> */
		public static final int CXObjCPropertyAttr_atomic = 0x100;
		/** <i>native declaration : clang-c/Index.h:3575</i> */
		public static final int CXObjCPropertyAttr_weak = 0x200;
		/** <i>native declaration : clang-c/Index.h:3576</i> */
		public static final int CXObjCPropertyAttr_strong = 0x400;
		/** <i>native declaration : clang-c/Index.h:3577</i> */
		public static final int CXObjCPropertyAttr_unsafe_unretained = 0x800;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXObjCDeclQualifierKind {
		/** <i>native declaration : clang-c/Index.h:3595</i> */
		public static final int CXObjCDeclQualifier_None = 0x0;
		/** <i>native declaration : clang-c/Index.h:3596</i> */
		public static final int CXObjCDeclQualifier_In = 0x1;
		/** <i>native declaration : clang-c/Index.h:3597</i> */
		public static final int CXObjCDeclQualifier_Inout = 0x2;
		/** <i>native declaration : clang-c/Index.h:3598</i> */
		public static final int CXObjCDeclQualifier_Out = 0x4;
		/** <i>native declaration : clang-c/Index.h:3599</i> */
		public static final int CXObjCDeclQualifier_Bycopy = 0x8;
		/** <i>native declaration : clang-c/Index.h:3600</i> */
		public static final int CXObjCDeclQualifier_Byref = 0x10;
		/** <i>native declaration : clang-c/Index.h:3601</i> */
		public static final int CXObjCDeclQualifier_Oneway = 0x20;
	};
	/**
	 * <i>native declaration : clang-c/Index.h:3848</i><br>
	 * enum values
	 */
	public static interface CXNameRefFlags {
		/** <i>native declaration : clang-c/Index.h:3853</i> */
		public static final int CXNameRange_WantQualifier = 0x1;
		/** <i>native declaration : clang-c/Index.h:3859</i> */
		public static final int CXNameRange_WantTemplateArgs = 0x2;
		/** <i>native declaration : clang-c/Index.h:3871</i> */
		public static final int CXNameRange_WantSinglePiece = 0x4;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXTokenKind {
		/** <i>native declaration : clang-c/Index.h:3895</i> */
		public static final int CXToken_Punctuation = 0;
		/** <i>native declaration : clang-c/Index.h:3900</i> */
		public static final int CXToken_Keyword = 1;
		/** <i>native declaration : clang-c/Index.h:3905</i> */
		public static final int CXToken_Identifier = 2;
		/** <i>native declaration : clang-c/Index.h:3910</i> */
		public static final int CXToken_Literal = 3;
		/** <i>native declaration : clang-c/Index.h:3915</i> */
		public static final int CXToken_Comment = 4;
	};
	/**
	 * \brief Describes a single piece of text within a code-completion string.<br>
	 * Each "chunk" within a code-completion string (\c CXCompletionString) is<br>
	 * either a piece of text with a specific "kind" that describes how that text<br>
	 * should be interpreted by the client or is another completion string.<br>
	 * <i>native declaration : clang-c/Index.h:4097</i><br>
	 * enum values
	 */
	public static interface CXCompletionChunkKind {
		/** <i>native declaration : clang-c/Index.h:4131</i> */
		public static final int CXCompletionChunk_Optional = 0;
		/** <i>native declaration : clang-c/Index.h:4142</i> */
		public static final int CXCompletionChunk_TypedText = 1;
		/** <i>native declaration : clang-c/Index.h:4150</i> */
		public static final int CXCompletionChunk_Text = 2;
		/** <i>native declaration : clang-c/Index.h:4161</i> */
		public static final int CXCompletionChunk_Placeholder = 3;
		/** <i>native declaration : clang-c/Index.h:4171</i> */
		public static final int CXCompletionChunk_Informative = 4;
		/** <i>native declaration : clang-c/Index.h:4191</i> */
		public static final int CXCompletionChunk_CurrentParameter = 5;
		/** <i>native declaration : clang-c/Index.h:4196</i> */
		public static final int CXCompletionChunk_LeftParen = 6;
		/** <i>native declaration : clang-c/Index.h:4201</i> */
		public static final int CXCompletionChunk_RightParen = 7;
		/** <i>native declaration : clang-c/Index.h:4205</i> */
		public static final int CXCompletionChunk_LeftBracket = 8;
		/** <i>native declaration : clang-c/Index.h:4209</i> */
		public static final int CXCompletionChunk_RightBracket = 9;
		/** <i>native declaration : clang-c/Index.h:4213</i> */
		public static final int CXCompletionChunk_LeftBrace = 10;
		/** <i>native declaration : clang-c/Index.h:4217</i> */
		public static final int CXCompletionChunk_RightBrace = 11;
		/** <i>native declaration : clang-c/Index.h:4221</i> */
		public static final int CXCompletionChunk_LeftAngle = 12;
		/** <i>native declaration : clang-c/Index.h:4225</i> */
		public static final int CXCompletionChunk_RightAngle = 13;
		/** <i>native declaration : clang-c/Index.h:4229</i> */
		public static final int CXCompletionChunk_Comma = 14;
		/** <i>native declaration : clang-c/Index.h:4237</i> */
		public static final int CXCompletionChunk_ResultType = 15;
		/** <i>native declaration : clang-c/Index.h:4241</i> */
		public static final int CXCompletionChunk_Colon = 16;
		/** <i>native declaration : clang-c/Index.h:4245</i> */
		public static final int CXCompletionChunk_SemiColon = 17;
		/** <i>native declaration : clang-c/Index.h:4249</i> */
		public static final int CXCompletionChunk_Equal = 18;
		/** <i>native declaration : clang-c/Index.h:4253</i> */
		public static final int CXCompletionChunk_HorizontalSpace = 19;
		/** <i>native declaration : clang-c/Index.h:4258</i> */
		public static final int CXCompletionChunk_VerticalSpace = 20;
	};
	/**
	 * \brief Flags that can be passed to \c clang_codeCompleteAt() to<br>
	 * modify its behavior.<br>
	 * The enumerators in this enumeration can be bitwise-OR'd together to<br>
	 * provide multiple options to \c clang_codeCompleteAt().<br>
	 * <i>native declaration : clang-c/Index.h:4428</i><br>
	 * enum values
	 */
	public static interface CXCodeComplete_Flags {
		/** <i>native declaration : clang-c/Index.h:4433</i> */
		public static final int CXCodeComplete_IncludeMacros = 0x01;
		/** <i>native declaration : clang-c/Index.h:4439</i> */
		public static final int CXCodeComplete_IncludeCodePatterns = 0x02;
		/** <i>native declaration : clang-c/Index.h:4445</i> */
		public static final int CXCodeComplete_IncludeBriefComments = 0x04;
	};
	/**
	 * \brief Bits that represent the context under which completion is occurring.<br>
	 * The enumerators in this enumeration may be bitwise-OR'd together if multiple<br>
	 * contexts are occurring simultaneously.<br>
	 * <i>native declaration : clang-c/Index.h:4454</i><br>
	 * enum values
	 */
	public static interface CXCompletionContext {
		/** <i>native declaration : clang-c/Index.h:4459</i> */
		public static final int CXCompletionContext_Unexposed = 0;
		/** <i>native declaration : clang-c/Index.h:4464</i> */
		public static final int CXCompletionContext_AnyType = 1 << 0;
		/** <i>native declaration : clang-c/Index.h:4470</i> */
		public static final int CXCompletionContext_AnyValue = 1 << 1;
		/** <i>native declaration : clang-c/Index.h:4475</i> */
		public static final int CXCompletionContext_ObjCObjectValue = 1 << 2;
		/** <i>native declaration : clang-c/Index.h:4480</i> */
		public static final int CXCompletionContext_ObjCSelectorValue = 1 << 3;
		/** <i>native declaration : clang-c/Index.h:4485</i> */
		public static final int CXCompletionContext_CXXClassTypeValue = 1 << 4;
		/** <i>native declaration : clang-c/Index.h:4491</i> */
		public static final int CXCompletionContext_DotMemberAccess = 1 << 5;
		/** <i>native declaration : clang-c/Index.h:4496</i> */
		public static final int CXCompletionContext_ArrowMemberAccess = 1 << 6;
		/** <i>native declaration : clang-c/Index.h:4501</i> */
		public static final int CXCompletionContext_ObjCPropertyAccess = 1 << 7;
		/** <i>native declaration : clang-c/Index.h:4506</i> */
		public static final int CXCompletionContext_EnumTag = 1 << 8;
		/** <i>native declaration : clang-c/Index.h:4510</i> */
		public static final int CXCompletionContext_UnionTag = 1 << 9;
		/** <i>native declaration : clang-c/Index.h:4514</i> */
		public static final int CXCompletionContext_StructTag = 1 << 10;
		/** <i>native declaration : clang-c/Index.h:4519</i> */
		public static final int CXCompletionContext_ClassTag = 1 << 11;
		/** <i>native declaration : clang-c/Index.h:4524</i> */
		public static final int CXCompletionContext_Namespace = 1 << 12;
		/** <i>native declaration : clang-c/Index.h:4529</i> */
		public static final int CXCompletionContext_NestedNameSpecifier = 1 << 13;
		/** <i>native declaration : clang-c/Index.h:4535</i> */
		public static final int CXCompletionContext_ObjCInterface = 1 << 14;
		/** <i>native declaration : clang-c/Index.h:4540</i> */
		public static final int CXCompletionContext_ObjCProtocol = 1 << 15;
		/** <i>native declaration : clang-c/Index.h:4545</i> */
		public static final int CXCompletionContext_ObjCCategory = 1 << 16;
		/** <i>native declaration : clang-c/Index.h:4550</i> */
		public static final int CXCompletionContext_ObjCInstanceMessage = 1 << 17;
		/** <i>native declaration : clang-c/Index.h:4555</i> */
		public static final int CXCompletionContext_ObjCClassMessage = 1 << 18;
		/** <i>native declaration : clang-c/Index.h:4560</i> */
		public static final int CXCompletionContext_ObjCSelectorName = 1 << 19;
		/** <i>native declaration : clang-c/Index.h:4566</i> */
		public static final int CXCompletionContext_MacroName = 1 << 20;
		/** <i>native declaration : clang-c/Index.h:4571</i> */
		public static final int CXCompletionContext_NaturalLanguage = 1 << 21;
		/** <i>native declaration : clang-c/Index.h:4576</i> */
		public static final int CXCompletionContext_Unknown = ((1 << 22) - 1);
	};
	/**
	 * \defgroup CINDEX_HIGH Higher level API functions<br>
	 * @{<br>
	 * <i>native declaration : clang-c/Index.h:4880</i><br>
	 * enum values
	 */
	public static interface CXVisitorResult {
		/** <i>native declaration : clang-c/Index.h:4881</i> */
		public static final int CXVisit_Break = 0;
		/** <i>native declaration : clang-c/Index.h:4882</i> */
		public static final int CXVisit_Continue = 1;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXResult {
		/** <i>native declaration : clang-c/Index.h:4894</i> */
		public static final int CXResult_Success = 0;
		/** <i>native declaration : clang-c/Index.h:4898</i> */
		public static final int CXResult_Invalid = 1;
		/** <i>native declaration : clang-c/Index.h:4903</i> */
		public static final int CXResult_VisitBreak = 2;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityKind {
		/** <i>native declaration : clang-c/Index.h:5037</i> */
		public static final int CXIdxEntity_Unexposed = 0;
		/** <i>native declaration : clang-c/Index.h:5038</i> */
		public static final int CXIdxEntity_Typedef = 1;
		/** <i>native declaration : clang-c/Index.h:5039</i> */
		public static final int CXIdxEntity_Function = 2;
		/** <i>native declaration : clang-c/Index.h:5040</i> */
		public static final int CXIdxEntity_Variable = 3;
		/** <i>native declaration : clang-c/Index.h:5041</i> */
		public static final int CXIdxEntity_Field = 4;
		/** <i>native declaration : clang-c/Index.h:5042</i> */
		public static final int CXIdxEntity_EnumConstant = 5;
		/** <i>native declaration : clang-c/Index.h:5044</i> */
		public static final int CXIdxEntity_ObjCClass = 6;
		/** <i>native declaration : clang-c/Index.h:5045</i> */
		public static final int CXIdxEntity_ObjCProtocol = 7;
		/** <i>native declaration : clang-c/Index.h:5046</i> */
		public static final int CXIdxEntity_ObjCCategory = 8;
		/** <i>native declaration : clang-c/Index.h:5048</i> */
		public static final int CXIdxEntity_ObjCInstanceMethod = 9;
		/** <i>native declaration : clang-c/Index.h:5049</i> */
		public static final int CXIdxEntity_ObjCClassMethod = 10;
		/** <i>native declaration : clang-c/Index.h:5050</i> */
		public static final int CXIdxEntity_ObjCProperty = 11;
		/** <i>native declaration : clang-c/Index.h:5051</i> */
		public static final int CXIdxEntity_ObjCIvar = 12;
		/** <i>native declaration : clang-c/Index.h:5053</i> */
		public static final int CXIdxEntity_Enum = 13;
		/** <i>native declaration : clang-c/Index.h:5054</i> */
		public static final int CXIdxEntity_Struct = 14;
		/** <i>native declaration : clang-c/Index.h:5055</i> */
		public static final int CXIdxEntity_Union = 15;
		/** <i>native declaration : clang-c/Index.h:5057</i> */
		public static final int CXIdxEntity_CXXClass = 16;
		/** <i>native declaration : clang-c/Index.h:5058</i> */
		public static final int CXIdxEntity_CXXNamespace = 17;
		/** <i>native declaration : clang-c/Index.h:5059</i> */
		public static final int CXIdxEntity_CXXNamespaceAlias = 18;
		/** <i>native declaration : clang-c/Index.h:5060</i> */
		public static final int CXIdxEntity_CXXStaticVariable = 19;
		/** <i>native declaration : clang-c/Index.h:5061</i> */
		public static final int CXIdxEntity_CXXStaticMethod = 20;
		/** <i>native declaration : clang-c/Index.h:5062</i> */
		public static final int CXIdxEntity_CXXInstanceMethod = 21;
		/** <i>native declaration : clang-c/Index.h:5063</i> */
		public static final int CXIdxEntity_CXXConstructor = 22;
		/** <i>native declaration : clang-c/Index.h:5064</i> */
		public static final int CXIdxEntity_CXXDestructor = 23;
		/** <i>native declaration : clang-c/Index.h:5065</i> */
		public static final int CXIdxEntity_CXXConversionFunction = 24;
		/** <i>native declaration : clang-c/Index.h:5066</i> */
		public static final int CXIdxEntity_CXXTypeAlias = 25;
		/** <i>native declaration : clang-c/Index.h:5067</i> */
		public static final int CXIdxEntity_CXXInterface = 26;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityLanguage {
		/** <i>native declaration : clang-c/Index.h:5072</i> */
		public static final int CXIdxEntityLang_None = 0;
		/** <i>native declaration : clang-c/Index.h:5073</i> */
		public static final int CXIdxEntityLang_C = 1;
		/** <i>native declaration : clang-c/Index.h:5074</i> */
		public static final int CXIdxEntityLang_ObjC = 2;
		/** <i>native declaration : clang-c/Index.h:5075</i> */
		public static final int CXIdxEntityLang_CXX = 3;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityCXXTemplateKind {
		/** <i>native declaration : clang-c/Index.h:5089</i> */
		public static final int CXIdxEntity_NonTemplate = 0;
		/** <i>native declaration : clang-c/Index.h:5090</i> */
		public static final int CXIdxEntity_Template = 1;
		/** <i>native declaration : clang-c/Index.h:5091</i> */
		public static final int CXIdxEntity_TemplatePartialSpecialization = 2;
		/** <i>native declaration : clang-c/Index.h:5092</i> */
		public static final int CXIdxEntity_TemplateSpecialization = 3;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxAttrKind {
		/** <i>native declaration : clang-c/Index.h:5096</i> */
		public static final int CXIdxAttr_Unexposed = 0;
		/** <i>native declaration : clang-c/Index.h:5097</i> */
		public static final int CXIdxAttr_IBAction = 1;
		/** <i>native declaration : clang-c/Index.h:5098</i> */
		public static final int CXIdxAttr_IBOutlet = 2;
		/** <i>native declaration : clang-c/Index.h:5099</i> */
		public static final int CXIdxAttr_IBOutletCollection = 3;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxDeclInfoFlags {
		/** <i>native declaration : clang-c/Index.h:5131</i> */
		public static final int CXIdxDeclFlag_Skipped = 0x1;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxObjCContainerKind {
		/** <i>native declaration : clang-c/Index.h:5161</i> */
		public static final int CXIdxObjCContainer_ForwardRef = 0;
		/** <i>native declaration : clang-c/Index.h:5162</i> */
		public static final int CXIdxObjCContainer_Interface = 1;
		/** <i>native declaration : clang-c/Index.h:5163</i> */
		public static final int CXIdxObjCContainer_Implementation = 2;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIdxEntityRefKind {
		/** <i>native declaration : clang-c/Index.h:5221</i> */
		public static final int CXIdxEntityRef_Direct = 1;
		/** <i>native declaration : clang-c/Index.h:5226</i> */
		public static final int CXIdxEntityRef_Implicit = 2;
	};
	/**
	 * <i>native declaration : clang-c/Index.h</i><br>
	 * enum values
	 */
	public static interface CXIndexOptFlags {
		/** <i>native declaration : clang-c/Index.h:5390</i> */
		public static final int CXIndexOpt_None = 0x0;
		/** <i>native declaration : clang-c/Index.h:5397</i> */
		public static final int CXIndexOpt_SuppressRedundantRefs = 0x1;
		/** <i>native declaration : clang-c/Index.h:5403</i> */
		public static final int CXIndexOpt_IndexFunctionLocalSymbols = 0x2;
		/** <i>native declaration : clang-c/Index.h:5409</i> */
		public static final int CXIndexOpt_IndexImplicitTemplateInstantiations = 0x4;
		/** <i>native declaration : clang-c/Index.h:5414</i> */
		public static final int CXIndexOpt_SuppressWarnings = 0x8;
		/** <i>native declaration : clang-c/Index.h:5421</i> */
		public static final int CXIndexOpt_SkipParsedBodiesInSession = 0x10;
	};
	/**
	 * \brief Describes the type of the comment AST node (\c CXComment).  A comment<br>
	 * node can be considered block content (e. g., paragraph), inline content<br>
	 * (plain text) or neither (the root AST node).<br>
	 * <i>native declaration : clang-c/Documentation.h:53</i><br>
	 * enum values
	 */
	public static interface CXCommentKind {
		/** <i>native declaration : clang-c/Documentation.h:58</i> */
		public static final int CXComment_Null = 0;
		/** <i>native declaration : clang-c/Documentation.h:63</i> */
		public static final int CXComment_Text = 1;
		/** <i>native declaration : clang-c/Documentation.h:70</i> */
		public static final int CXComment_InlineCommand = 2;
		/** <i>native declaration : clang-c/Documentation.h:81</i> */
		public static final int CXComment_HTMLStartTag = 3;
		/** <i>native declaration : clang-c/Documentation.h:91</i> */
		public static final int CXComment_HTMLEndTag = 4;
		/** <i>native declaration : clang-c/Documentation.h:97</i> */
		public static final int CXComment_Paragraph = 5;
		/** <i>native declaration : clang-c/Documentation.h:111</i> */
		public static final int CXComment_BlockCommand = 6;
		/** <i>native declaration : clang-c/Documentation.h:119</i> */
		public static final int CXComment_ParamCommand = 7;
		/** <i>native declaration : clang-c/Documentation.h:127</i> */
		public static final int CXComment_TParamCommand = 8;
		/** <i>native declaration : clang-c/Documentation.h:139</i> */
		public static final int CXComment_VerbatimBlockCommand = 9;
		/** <i>native declaration : clang-c/Documentation.h:145</i> */
		public static final int CXComment_VerbatimBlockLine = 10;
		/** <i>native declaration : clang-c/Documentation.h:152</i> */
		public static final int CXComment_VerbatimLine = 11;
		/** <i>native declaration : clang-c/Documentation.h:157</i> */
		public static final int CXComment_FullComment = 12;
	};
	/**
	 * \brief The most appropriate rendering mode for an inline command, chosen on<br>
	 * command semantics in Doxygen.<br>
	 * <i>native declaration : clang-c/Documentation.h:164</i><br>
	 * enum values
	 */
	public static interface CXCommentInlineCommandRenderKind {
		/** <i>native declaration : clang-c/Documentation.h:168</i> */
		public static final int CXCommentInlineCommandRenderKind_Normal = 0;
		/** <i>native declaration : clang-c/Documentation.h:173</i> */
		public static final int CXCommentInlineCommandRenderKind_Bold = 1;
		/** <i>native declaration : clang-c/Documentation.h:178</i> */
		public static final int CXCommentInlineCommandRenderKind_Monospaced = 2;
		/** <i>native declaration : clang-c/Documentation.h:184</i> */
		public static final int CXCommentInlineCommandRenderKind_Emphasized = 3;
	};
	/**
	 * \brief Describes parameter passing direction for \\param or \\arg command.<br>
	 * <i>native declaration : clang-c/Documentation.h:190</i><br>
	 * enum values
	 */
	public static interface CXCommentParamPassDirection {
		/** <i>native declaration : clang-c/Documentation.h:194</i> */
		public static final int CXCommentParamPassDirection_In = 0;
		/** <i>native declaration : clang-c/Documentation.h:199</i> */
		public static final int CXCommentParamPassDirection_Out = 1;
		/** <i>native declaration : clang-c/Documentation.h:204</i> */
		public static final int CXCommentParamPassDirection_InOut = 2;
	};
	/**
	 * <i>native declaration : clang-c/CXCompilationDatabase.h</i><br>
	 * enum values
	 */
	public static interface CXCompilationDatabase_Error {
		/** <i>native declaration : clang-c/CXCompilationDatabase.h:44</i> */
		public static final int CXCompilationDatabase_NoError = 0;
		/** <i>native declaration : clang-c/CXCompilationDatabase.h:49</i> */
		public static final int CXCompilationDatabase_CanNotLoadDatabase = 1;
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static final int CINDEX_VERSION_MINOR = (int)28;
	/** <i>native declaration : clang-c/Index.h</i> */
	public static final int CINDEX_VERSION_MAJOR = (int)0;
	/** <i>native declaration : clang-c/Index.h</i> */
	public static final String CINDEX_VERSION_STRING = (String)"0";
	/** <i>native declaration : clang-c/Index.h</i> */
	public static final int CINDEX_VERSION = (int)(((0) * 10000) + ((28) * 1));
	/** <i>native declaration : clang-c/CXString.h</i> */
	public static class CXString extends Structure<CXString, CXString.ByValue, CXString.ByReference > {
		/** C type : const void* */
		public Pointer data;
		public int private_flags;
		public CXString() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("data", "private_flags");
		}
		/** @param data C type : const void* */
		public CXString(Pointer data, int private_flags) {
			super();
			this.data = data;
			this.private_flags = private_flags;
		}
		public CXString(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXString newInstance() { return new CXString(); }
		public static CXString[] newArray(int arrayLength) {
			return Structure.newArray(CXString.class, arrayLength);
		}
		public static class ByReference extends CXString implements Structure.ByReference {
			
		};
		public static class ByValue extends CXString implements Structure.ByValue {
			
		};
	};
	/**
	 * \brief Provides the contents of a file that has not yet been saved to disk.<br>
	 * Each CXUnsavedFile instance provides the name of a file on the<br>
	 * system along with the current contents of that file that have not<br>
	 * yet been saved to disk.<br>
	 * <i>native declaration : clang-c/Index.h:100</i>
	 */
	public static class CXUnsavedFile extends Structure<CXUnsavedFile, CXUnsavedFile.ByValue, CXUnsavedFile.ByReference > {
		/** C type : const char* */
		public Pointer Filename;
		/** C type : const char* */
		public Pointer Contents;
		public NativeLong Length;
		public CXUnsavedFile() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("Filename", "Contents", "Length");
		}
		/**
		 * @param Filename C type : const char*<br>
		 * @param Contents C type : const char*
		 */
		public CXUnsavedFile(Pointer Filename, Pointer Contents, NativeLong Length) {
			super();
			this.Filename = Filename;
			this.Contents = Contents;
			this.Length = Length;
		}
		public CXUnsavedFile(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXUnsavedFile newInstance() { return new CXUnsavedFile(); }
		public static CXUnsavedFile[] newArray(int arrayLength) {
			return Structure.newArray(CXUnsavedFile.class, arrayLength);
		}
		public static class ByReference extends CXUnsavedFile implements Structure.ByReference {
			
		};
		public static class ByValue extends CXUnsavedFile implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXVersion extends Structure<CXVersion, CXVersion.ByValue, CXVersion.ByReference > {
		public int Major;
		public int Minor;
		public int Subminor;
		public CXVersion() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("Major", "Minor", "Subminor");
		}
		public CXVersion(int Major, int Minor, int Subminor) {
			super();
			this.Major = Major;
			this.Minor = Minor;
			this.Subminor = Subminor;
		}
		public CXVersion(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXVersion newInstance() { return new CXVersion(); }
		public static CXVersion[] newArray(int arrayLength) {
			return Structure.newArray(CXVersion.class, arrayLength);
		}
		public static class ByReference extends CXVersion implements Structure.ByReference {
			
		};
		public static class ByValue extends CXVersion implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXFileUniqueID extends Structure<CXFileUniqueID, CXFileUniqueID.ByValue, CXFileUniqueID.ByReference > {
		/** C type : unsigned long long[3] */
		public long[] data = new long[3];
		public CXFileUniqueID() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("data");
		}
		/** @param data C type : unsigned long long[3] */
		public CXFileUniqueID(long data[]) {
			super();
			if ((data.length != this.data.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.data = data;
		}
		public CXFileUniqueID(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXFileUniqueID newInstance() { return new CXFileUniqueID(); }
		public static CXFileUniqueID[] newArray(int arrayLength) {
			return Structure.newArray(CXFileUniqueID.class, arrayLength);
		}
		public static class ByReference extends CXFileUniqueID implements Structure.ByReference {
			
		};
		public static class ByValue extends CXFileUniqueID implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXSourceLocation extends Structure<CXSourceLocation, CXSourceLocation.ByValue, CXSourceLocation.ByReference > {
		/** C type : const void*[2] */
		public Pointer[] ptr_data = new Pointer[2];
		public int int_data;
		public CXSourceLocation() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("ptr_data", "int_data");
		}
		/** @param ptr_data C type : const void*[2] */
		public CXSourceLocation(Pointer ptr_data[], int int_data) {
			super();
			if ((ptr_data.length != this.ptr_data.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.ptr_data = ptr_data;
			this.int_data = int_data;
		}
		public CXSourceLocation(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXSourceLocation newInstance() { return new CXSourceLocation(); }
		public static CXSourceLocation[] newArray(int arrayLength) {
			return Structure.newArray(CXSourceLocation.class, arrayLength);
		}
		public static class ByReference extends CXSourceLocation implements Structure.ByReference {
			
		};
		public static class ByValue extends CXSourceLocation implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXSourceRange extends Structure<CXSourceRange, CXSourceRange.ByValue, CXSourceRange.ByReference > {
		/** C type : const void*[2] */
		public Pointer[] ptr_data = new Pointer[2];
		public int begin_int_data;
		public int end_int_data;
		public CXSourceRange() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("ptr_data", "begin_int_data", "end_int_data");
		}
		/** @param ptr_data C type : const void*[2] */
		public CXSourceRange(Pointer ptr_data[], int begin_int_data, int end_int_data) {
			super();
			if ((ptr_data.length != this.ptr_data.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.ptr_data = ptr_data;
			this.begin_int_data = begin_int_data;
			this.end_int_data = end_int_data;
		}
		public CXSourceRange(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXSourceRange newInstance() { return new CXSourceRange(); }
		public static CXSourceRange[] newArray(int arrayLength) {
			return Structure.newArray(CXSourceRange.class, arrayLength);
		}
		public static class ByReference extends CXSourceRange implements Structure.ByReference {
			
		};
		public static class ByValue extends CXSourceRange implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXSourceRangeList extends Structure<CXSourceRangeList, CXSourceRangeList.ByValue, CXSourceRangeList.ByReference > {
		public int count;
		/** C type : CXSourceRange* */
		public ClangLibrary.CXSourceRange.ByReference ranges;
		public CXSourceRangeList() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("count", "ranges");
		}
		/** @param ranges C type : CXSourceRange* */
		public CXSourceRangeList(int count, ClangLibrary.CXSourceRange.ByReference ranges) {
			super();
			this.count = count;
			this.ranges = ranges;
		}
		public CXSourceRangeList(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXSourceRangeList newInstance() { return new CXSourceRangeList(); }
		public static CXSourceRangeList[] newArray(int arrayLength) {
			return Structure.newArray(CXSourceRangeList.class, arrayLength);
		}
		public static class ByReference extends CXSourceRangeList implements Structure.ByReference {
			
		};
		public static class ByValue extends CXSourceRangeList implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXTUResourceUsageEntry extends Structure<CXTUResourceUsageEntry, CXTUResourceUsageEntry.ByValue, CXTUResourceUsageEntry.ByReference > {
		/**
		 * @see CXTUResourceUsageKind<br>
		 * C type : CXTUResourceUsageKind
		 */
		public int kind;
		public NativeLong amount;
		public CXTUResourceUsageEntry() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("kind", "amount");
		}
		/**
		 * @param kind @see CXTUResourceUsageKind<br>
		 * C type : CXTUResourceUsageKind
		 */
		public CXTUResourceUsageEntry(int kind, NativeLong amount) {
			super();
			this.kind = kind;
			this.amount = amount;
		}
		public CXTUResourceUsageEntry(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXTUResourceUsageEntry newInstance() { return new CXTUResourceUsageEntry(); }
		public static CXTUResourceUsageEntry[] newArray(int arrayLength) {
			return Structure.newArray(CXTUResourceUsageEntry.class, arrayLength);
		}
		public static class ByReference extends CXTUResourceUsageEntry implements Structure.ByReference {
			
		};
		public static class ByValue extends CXTUResourceUsageEntry implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXTUResourceUsage extends Structure<CXTUResourceUsage, CXTUResourceUsage.ByValue, CXTUResourceUsage.ByReference > {
		/** C type : void* */
		public Pointer data;
		public int numEntries;
		/** C type : CXTUResourceUsageEntry* */
		public ClangLibrary.CXTUResourceUsageEntry.ByReference entries;
		public CXTUResourceUsage() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("data", "numEntries", "entries");
		}
		/**
		 * @param data C type : void*<br>
		 * @param entries C type : CXTUResourceUsageEntry*
		 */
		public CXTUResourceUsage(Pointer data, int numEntries, ClangLibrary.CXTUResourceUsageEntry.ByReference entries) {
			super();
			this.data = data;
			this.numEntries = numEntries;
			this.entries = entries;
		}
		public CXTUResourceUsage(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXTUResourceUsage newInstance() { return new CXTUResourceUsage(); }
		public static CXTUResourceUsage[] newArray(int arrayLength) {
			return Structure.newArray(CXTUResourceUsage.class, arrayLength);
		}
		public static class ByReference extends CXTUResourceUsage implements Structure.ByReference {
			
		};
		public static class ByValue extends CXTUResourceUsage implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXCursor extends Structure<CXCursor, CXCursor.ByValue, CXCursor.ByReference > {
		/**
		 * @see CXCursorKind<br>
		 * C type : CXCursorKind
		 */
		public int kind;
		public int xdata;
		/** C type : const void*[3] */
		public Pointer[] data = new Pointer[3];
		public CXCursor() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("kind", "xdata", "data");
		}
		/**
		 * @param kind @see CXCursorKind<br>
		 * C type : CXCursorKind<br>
		 * @param data C type : const void*[3]
		 */
		public CXCursor(int kind, int xdata, Pointer data[]) {
			super();
			this.kind = kind;
			this.xdata = xdata;
			if ((data.length != this.data.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.data = data;
		}
		public CXCursor(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXCursor newInstance() { return new CXCursor(); }
		public static CXCursor[] newArray(int arrayLength) {
			return Structure.newArray(CXCursor.class, arrayLength);
		}
		public static class ByReference extends CXCursor implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCursor implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXPlatformAvailability extends Structure<CXPlatformAvailability, CXPlatformAvailability.ByValue, CXPlatformAvailability.ByReference > {
		/** C type : CXString */
		public ClangLibrary.CXString Platform;
		/** C type : CXVersion */
		public ClangLibrary.CXVersion Introduced;
		/** C type : CXVersion */
		public ClangLibrary.CXVersion Deprecated;
		/** C type : CXVersion */
		public ClangLibrary.CXVersion Obsoleted;
		public int Unavailable;
		/** C type : CXString */
		public ClangLibrary.CXString Message;
		public CXPlatformAvailability() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("Platform", "Introduced", "Deprecated", "Obsoleted", "Unavailable", "Message");
		}
		/**
		 * @param Platform C type : CXString<br>
		 * @param Introduced C type : CXVersion<br>
		 * @param Deprecated C type : CXVersion<br>
		 * @param Obsoleted C type : CXVersion<br>
		 * @param Message C type : CXString
		 */
		public CXPlatformAvailability(ClangLibrary.CXString Platform, ClangLibrary.CXVersion Introduced, ClangLibrary.CXVersion Deprecated, ClangLibrary.CXVersion Obsoleted, int Unavailable, ClangLibrary.CXString Message) {
			super();
			this.Platform = Platform;
			this.Introduced = Introduced;
			this.Deprecated = Deprecated;
			this.Obsoleted = Obsoleted;
			this.Unavailable = Unavailable;
			this.Message = Message;
		}
		public CXPlatformAvailability(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXPlatformAvailability newInstance() { return new CXPlatformAvailability(); }
		public static CXPlatformAvailability[] newArray(int arrayLength) {
			return Structure.newArray(CXPlatformAvailability.class, arrayLength);
		}
		public static class ByReference extends CXPlatformAvailability implements Structure.ByReference {
			
		};
		public static class ByValue extends CXPlatformAvailability implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXType extends Structure<CXType, CXType.ByValue, CXType.ByReference > {
		/**
		 * @see CXTypeKind<br>
		 * C type : CXTypeKind
		 */
		public int kind;
		/** C type : void*[2] */
		public Pointer[] data = new Pointer[2];
		public CXType() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("kind", "data");
		}
		/**
		 * @param kind @see CXTypeKind<br>
		 * C type : CXTypeKind<br>
		 * @param data C type : void*[2]
		 */
		public CXType(int kind, Pointer data[]) {
			super();
			this.kind = kind;
			if ((data.length != this.data.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.data = data;
		}
		public CXType(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXType newInstance() { return new CXType(); }
		public static CXType[] newArray(int arrayLength) {
			return Structure.newArray(CXType.class, arrayLength);
		}
		public static class ByReference extends CXType implements Structure.ByReference {
			
		};
		public static class ByValue extends CXType implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXToken extends Structure<CXToken, CXToken.ByValue, CXToken.ByReference > {
		/** C type : unsigned[4] */
		public int[] int_data = new int[4];
		/** C type : void* */
		public Pointer ptr_data;
		public CXToken() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("int_data", "ptr_data");
		}
		/**
		 * @param int_data C type : unsigned[4]<br>
		 * @param ptr_data C type : void*
		 */
		public CXToken(int int_data[], Pointer ptr_data) {
			super();
			if ((int_data.length != this.int_data.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.int_data = int_data;
			this.ptr_data = ptr_data;
		}
		public CXToken(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXToken newInstance() { return new CXToken(); }
		public static CXToken[] newArray(int arrayLength) {
			return Structure.newArray(CXToken.class, arrayLength);
		}
		public static class ByReference extends CXToken implements Structure.ByReference {
			
		};
		public static class ByValue extends CXToken implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXCompletionResult extends Structure<CXCompletionResult, CXCompletionResult.ByValue, CXCompletionResult.ByReference > {
		/**
		 * @see CXCursorKind<br>
		 * C type : CXCursorKind
		 */
		public int CursorKind;
		/** C type : CXCompletionString */
		public Pointer CompletionString;
		public CXCompletionResult() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("CursorKind", "CompletionString");
		}
		/**
		 * @param CursorKind @see CXCursorKind<br>
		 * C type : CXCursorKind<br>
		 * @param CompletionString C type : CXCompletionString
		 */
		public CXCompletionResult(int CursorKind, Pointer CompletionString) {
			super();
			this.CursorKind = CursorKind;
			this.CompletionString = CompletionString;
		}
		public CXCompletionResult(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXCompletionResult newInstance() { return new CXCompletionResult(); }
		public static CXCompletionResult[] newArray(int arrayLength) {
			return Structure.newArray(CXCompletionResult.class, arrayLength);
		}
		public static class ByReference extends CXCompletionResult implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCompletionResult implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXCodeCompleteResults extends Structure<CXCodeCompleteResults, CXCodeCompleteResults.ByValue, CXCodeCompleteResults.ByReference > {
		/** C type : CXCompletionResult* */
		public ClangLibrary.CXCompletionResult.ByReference Results;
		public int NumResults;
		public CXCodeCompleteResults() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("Results", "NumResults");
		}
		/** @param Results C type : CXCompletionResult* */
		public CXCodeCompleteResults(ClangLibrary.CXCompletionResult.ByReference Results, int NumResults) {
			super();
			this.Results = Results;
			this.NumResults = NumResults;
		}
		public CXCodeCompleteResults(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXCodeCompleteResults newInstance() { return new CXCodeCompleteResults(); }
		public static CXCodeCompleteResults[] newArray(int arrayLength) {
			return Structure.newArray(CXCodeCompleteResults.class, arrayLength);
		}
		public static class ByReference extends CXCodeCompleteResults implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCodeCompleteResults implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXCursorAndRangeVisitor extends Structure<CXCursorAndRangeVisitor, CXCursorAndRangeVisitor.ByValue, CXCursorAndRangeVisitor.ByReference > {
		/** C type : void* */
		public Pointer context;
		/** C type : visit_callback* */
		public ClangLibrary.CXCursorAndRangeVisitor.visit_callback visit;
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface visit_callback extends Callback {
			int apply(Pointer context, ClangLibrary.CXCursor.ByValue CXCursor1, ClangLibrary.CXSourceRange.ByValue CXSourceRange1);
		};
		public CXCursorAndRangeVisitor() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("context", "visit");
		}
		/**
		 * @param context C type : void*<br>
		 * @param visit C type : visit_callback*
		 */
		public CXCursorAndRangeVisitor(Pointer context, ClangLibrary.CXCursorAndRangeVisitor.visit_callback visit) {
			super();
			this.context = context;
			this.visit = visit;
		}
		public CXCursorAndRangeVisitor(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXCursorAndRangeVisitor newInstance() { return new CXCursorAndRangeVisitor(); }
		public static CXCursorAndRangeVisitor[] newArray(int arrayLength) {
			return Structure.newArray(CXCursorAndRangeVisitor.class, arrayLength);
		}
		public static class ByReference extends CXCursorAndRangeVisitor implements Structure.ByReference {
			
		};
		public static class ByValue extends CXCursorAndRangeVisitor implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxLoc extends Structure<CXIdxLoc, CXIdxLoc.ByValue, CXIdxLoc.ByReference > {
		/** C type : void*[2] */
		public Pointer[] ptr_data = new Pointer[2];
		public int int_data;
		public CXIdxLoc() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("ptr_data", "int_data");
		}
		/** @param ptr_data C type : void*[2] */
		public CXIdxLoc(Pointer ptr_data[], int int_data) {
			super();
			if ((ptr_data.length != this.ptr_data.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.ptr_data = ptr_data;
			this.int_data = int_data;
		}
		public CXIdxLoc(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxLoc newInstance() { return new CXIdxLoc(); }
		public static CXIdxLoc[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxLoc.class, arrayLength);
		}
		public static class ByReference extends CXIdxLoc implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxLoc implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxIncludedFileInfo extends Structure<CXIdxIncludedFileInfo, CXIdxIncludedFileInfo.ByValue, CXIdxIncludedFileInfo.ByReference > {
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc hashLoc;
		/** C type : const char* */
		public Pointer filename;
		/** C type : CXFile */
		public Pointer file;
		public int isImport;
		public int isAngled;
		public int isModuleImport;
		public CXIdxIncludedFileInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("hashLoc", "filename", "file", "isImport", "isAngled", "isModuleImport");
		}
		/**
		 * @param hashLoc C type : CXIdxLoc<br>
		 * @param filename C type : const char*<br>
		 * @param file C type : CXFile
		 */
		public CXIdxIncludedFileInfo(ClangLibrary.CXIdxLoc hashLoc, Pointer filename, Pointer file, int isImport, int isAngled, int isModuleImport) {
			super();
			this.hashLoc = hashLoc;
			this.filename = filename;
			this.file = file;
			this.isImport = isImport;
			this.isAngled = isAngled;
			this.isModuleImport = isModuleImport;
		}
		public CXIdxIncludedFileInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxIncludedFileInfo newInstance() { return new CXIdxIncludedFileInfo(); }
		public static CXIdxIncludedFileInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxIncludedFileInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxIncludedFileInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxIncludedFileInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxImportedASTFileInfo extends Structure<CXIdxImportedASTFileInfo, CXIdxImportedASTFileInfo.ByValue, CXIdxImportedASTFileInfo.ByReference > {
		/** C type : CXFile */
		public Pointer file;
		/** C type : CXModule */
		public Pointer module;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc loc;
		public int isImplicit;
		public CXIdxImportedASTFileInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("file", "module", "loc", "isImplicit");
		}
		/**
		 * @param file C type : CXFile<br>
		 * @param module C type : CXModule<br>
		 * @param loc C type : CXIdxLoc
		 */
		public CXIdxImportedASTFileInfo(Pointer file, Pointer module, ClangLibrary.CXIdxLoc loc, int isImplicit) {
			super();
			this.file = file;
			this.module = module;
			this.loc = loc;
			this.isImplicit = isImplicit;
		}
		public CXIdxImportedASTFileInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxImportedASTFileInfo newInstance() { return new CXIdxImportedASTFileInfo(); }
		public static CXIdxImportedASTFileInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxImportedASTFileInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxImportedASTFileInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxImportedASTFileInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxAttrInfo extends Structure<CXIdxAttrInfo, CXIdxAttrInfo.ByValue, CXIdxAttrInfo.ByReference > {
		/**
		 * @see CXIdxAttrKind<br>
		 * C type : CXIdxAttrKind
		 */
		public int kind;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor cursor;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc loc;
		public CXIdxAttrInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("kind", "cursor", "loc");
		}
		/**
		 * @param kind @see CXIdxAttrKind<br>
		 * C type : CXIdxAttrKind<br>
		 * @param cursor C type : CXCursor<br>
		 * @param loc C type : CXIdxLoc
		 */
		public CXIdxAttrInfo(int kind, ClangLibrary.CXCursor cursor, ClangLibrary.CXIdxLoc loc) {
			super();
			this.kind = kind;
			this.cursor = cursor;
			this.loc = loc;
		}
		public CXIdxAttrInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxAttrInfo newInstance() { return new CXIdxAttrInfo(); }
		public static CXIdxAttrInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxAttrInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxAttrInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxAttrInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxEntityInfo extends Structure<CXIdxEntityInfo, CXIdxEntityInfo.ByValue, CXIdxEntityInfo.ByReference > {
		/**
		 * @see CXIdxEntityKind<br>
		 * C type : CXIdxEntityKind
		 */
		public int kind;
		/**
		 * @see CXIdxEntityCXXTemplateKind<br>
		 * C type : CXIdxEntityCXXTemplateKind
		 */
		public int templateKind;
		/**
		 * @see CXIdxEntityLanguage<br>
		 * C type : CXIdxEntityLanguage
		 */
		public int lang;
		/** C type : const char* */
		public Pointer name;
		/** C type : const char* */
		public Pointer USR;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor cursor;
		/** C type : const CXIdxAttrInfo** */
		public ClangLibrary.CXIdxAttrInfo.ByReference[] attributes;
		public int numAttributes;
		public CXIdxEntityInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("kind", "templateKind", "lang", "name", "USR", "cursor", "attributes", "numAttributes");
		}
		/**
		 * @param kind @see CXIdxEntityKind<br>
		 * C type : CXIdxEntityKind<br>
		 * @param templateKind @see CXIdxEntityCXXTemplateKind<br>
		 * C type : CXIdxEntityCXXTemplateKind<br>
		 * @param lang @see CXIdxEntityLanguage<br>
		 * C type : CXIdxEntityLanguage<br>
		 * @param name C type : const char*<br>
		 * @param USR C type : const char*<br>
		 * @param cursor C type : CXCursor<br>
		 * @param attributes C type : const CXIdxAttrInfo**
		 */
		public CXIdxEntityInfo(int kind, int templateKind, int lang, Pointer name, Pointer USR, ClangLibrary.CXCursor cursor, ClangLibrary.CXIdxAttrInfo.ByReference attributes[], int numAttributes) {
			super();
			this.kind = kind;
			this.templateKind = templateKind;
			this.lang = lang;
			this.name = name;
			this.USR = USR;
			this.cursor = cursor;
			if ((attributes.length != this.attributes.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.attributes = attributes;
			this.numAttributes = numAttributes;
		}
		public CXIdxEntityInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxEntityInfo newInstance() { return new CXIdxEntityInfo(); }
		public static CXIdxEntityInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxEntityInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxEntityInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxEntityInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxContainerInfo extends Structure<CXIdxContainerInfo, CXIdxContainerInfo.ByValue, CXIdxContainerInfo.ByReference > {
		/** C type : CXCursor */
		public ClangLibrary.CXCursor cursor;
		public CXIdxContainerInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("cursor");
		}
		/** @param cursor C type : CXCursor */
		public CXIdxContainerInfo(ClangLibrary.CXCursor cursor) {
			super();
			this.cursor = cursor;
		}
		public CXIdxContainerInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxContainerInfo newInstance() { return new CXIdxContainerInfo(); }
		public static CXIdxContainerInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxContainerInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxContainerInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxContainerInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxIBOutletCollectionAttrInfo extends Structure<CXIdxIBOutletCollectionAttrInfo, CXIdxIBOutletCollectionAttrInfo.ByValue, CXIdxIBOutletCollectionAttrInfo.ByReference > {
		/** C type : const CXIdxAttrInfo* */
		public ClangLibrary.CXIdxAttrInfo.ByReference attrInfo;
		/** C type : const CXIdxEntityInfo* */
		public ClangLibrary.CXIdxEntityInfo.ByReference objcClass;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor classCursor;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc classLoc;
		public CXIdxIBOutletCollectionAttrInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("attrInfo", "objcClass", "classCursor", "classLoc");
		}
		/**
		 * @param attrInfo C type : const CXIdxAttrInfo*<br>
		 * @param objcClass C type : const CXIdxEntityInfo*<br>
		 * @param classCursor C type : CXCursor<br>
		 * @param classLoc C type : CXIdxLoc
		 */
		public CXIdxIBOutletCollectionAttrInfo(ClangLibrary.CXIdxAttrInfo.ByReference attrInfo, ClangLibrary.CXIdxEntityInfo.ByReference objcClass, ClangLibrary.CXCursor classCursor, ClangLibrary.CXIdxLoc classLoc) {
			super();
			this.attrInfo = attrInfo;
			this.objcClass = objcClass;
			this.classCursor = classCursor;
			this.classLoc = classLoc;
		}
		public CXIdxIBOutletCollectionAttrInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxIBOutletCollectionAttrInfo newInstance() { return new CXIdxIBOutletCollectionAttrInfo(); }
		public static CXIdxIBOutletCollectionAttrInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxIBOutletCollectionAttrInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxIBOutletCollectionAttrInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxIBOutletCollectionAttrInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxDeclInfo extends Structure<CXIdxDeclInfo, CXIdxDeclInfo.ByValue, CXIdxDeclInfo.ByReference > {
		/** C type : const CXIdxEntityInfo* */
		public ClangLibrary.CXIdxEntityInfo.ByReference entityInfo;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor cursor;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc loc;
		/** C type : const CXIdxContainerInfo* */
		public ClangLibrary.CXIdxContainerInfo.ByReference semanticContainer;
		/** C type : const CXIdxContainerInfo* */
		public ClangLibrary.CXIdxContainerInfo.ByReference lexicalContainer;
		public int isRedeclaration;
		public int isDefinition;
		public int isContainer;
		/** C type : const CXIdxContainerInfo* */
		public ClangLibrary.CXIdxContainerInfo.ByReference declAsContainer;
		public int isImplicit;
		/** C type : const CXIdxAttrInfo** */
		public ClangLibrary.CXIdxAttrInfo.ByReference[] attributes;
		public int numAttributes;
		public int flags;
		public CXIdxDeclInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("entityInfo", "cursor", "loc", "semanticContainer", "lexicalContainer", "isRedeclaration", "isDefinition", "isContainer", "declAsContainer", "isImplicit", "attributes", "numAttributes", "flags");
		}
		public CXIdxDeclInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxDeclInfo newInstance() { return new CXIdxDeclInfo(); }
		public static CXIdxDeclInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxDeclInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxDeclInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxDeclInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxObjCContainerDeclInfo extends Structure<CXIdxObjCContainerDeclInfo, CXIdxObjCContainerDeclInfo.ByValue, CXIdxObjCContainerDeclInfo.ByReference > {
		/** C type : const CXIdxDeclInfo* */
		public ClangLibrary.CXIdxDeclInfo.ByReference declInfo;
		/**
		 * @see CXIdxObjCContainerKind<br>
		 * C type : CXIdxObjCContainerKind
		 */
		public int kind;
		public CXIdxObjCContainerDeclInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("declInfo", "kind");
		}
		/**
		 * @param declInfo C type : const CXIdxDeclInfo*<br>
		 * @param kind @see CXIdxObjCContainerKind<br>
		 * C type : CXIdxObjCContainerKind
		 */
		public CXIdxObjCContainerDeclInfo(ClangLibrary.CXIdxDeclInfo.ByReference declInfo, int kind) {
			super();
			this.declInfo = declInfo;
			this.kind = kind;
		}
		public CXIdxObjCContainerDeclInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxObjCContainerDeclInfo newInstance() { return new CXIdxObjCContainerDeclInfo(); }
		public static CXIdxObjCContainerDeclInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxObjCContainerDeclInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxObjCContainerDeclInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxObjCContainerDeclInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxBaseClassInfo extends Structure<CXIdxBaseClassInfo, CXIdxBaseClassInfo.ByValue, CXIdxBaseClassInfo.ByReference > {
		/** C type : const CXIdxEntityInfo* */
		public ClangLibrary.CXIdxEntityInfo.ByReference base;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor cursor;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc loc;
		public CXIdxBaseClassInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("base", "cursor", "loc");
		}
		/**
		 * @param base C type : const CXIdxEntityInfo*<br>
		 * @param cursor C type : CXCursor<br>
		 * @param loc C type : CXIdxLoc
		 */
		public CXIdxBaseClassInfo(ClangLibrary.CXIdxEntityInfo.ByReference base, ClangLibrary.CXCursor cursor, ClangLibrary.CXIdxLoc loc) {
			super();
			this.base = base;
			this.cursor = cursor;
			this.loc = loc;
		}
		public CXIdxBaseClassInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxBaseClassInfo newInstance() { return new CXIdxBaseClassInfo(); }
		public static CXIdxBaseClassInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxBaseClassInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxBaseClassInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxBaseClassInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxObjCProtocolRefInfo extends Structure<CXIdxObjCProtocolRefInfo, CXIdxObjCProtocolRefInfo.ByValue, CXIdxObjCProtocolRefInfo.ByReference > {
		/** C type : const CXIdxEntityInfo* */
		public ClangLibrary.CXIdxEntityInfo.ByReference protocol;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor cursor;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc loc;
		public CXIdxObjCProtocolRefInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("protocol", "cursor", "loc");
		}
		/**
		 * @param protocol C type : const CXIdxEntityInfo*<br>
		 * @param cursor C type : CXCursor<br>
		 * @param loc C type : CXIdxLoc
		 */
		public CXIdxObjCProtocolRefInfo(ClangLibrary.CXIdxEntityInfo.ByReference protocol, ClangLibrary.CXCursor cursor, ClangLibrary.CXIdxLoc loc) {
			super();
			this.protocol = protocol;
			this.cursor = cursor;
			this.loc = loc;
		}
		public CXIdxObjCProtocolRefInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxObjCProtocolRefInfo newInstance() { return new CXIdxObjCProtocolRefInfo(); }
		public static CXIdxObjCProtocolRefInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxObjCProtocolRefInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxObjCProtocolRefInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxObjCProtocolRefInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxObjCProtocolRefListInfo extends Structure<CXIdxObjCProtocolRefListInfo, CXIdxObjCProtocolRefListInfo.ByValue, CXIdxObjCProtocolRefListInfo.ByReference > {
		/** C type : const CXIdxObjCProtocolRefInfo** */
		public ClangLibrary.CXIdxObjCProtocolRefInfo.ByReference[] protocols;
		public int numProtocols;
		public CXIdxObjCProtocolRefListInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("protocols", "numProtocols");
		}
		/** @param protocols C type : const CXIdxObjCProtocolRefInfo** */
		public CXIdxObjCProtocolRefListInfo(ClangLibrary.CXIdxObjCProtocolRefInfo.ByReference protocols[], int numProtocols) {
			super();
			if ((protocols.length != this.protocols.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.protocols = protocols;
			this.numProtocols = numProtocols;
		}
		public CXIdxObjCProtocolRefListInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxObjCProtocolRefListInfo newInstance() { return new CXIdxObjCProtocolRefListInfo(); }
		public static CXIdxObjCProtocolRefListInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxObjCProtocolRefListInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxObjCProtocolRefListInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxObjCProtocolRefListInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxObjCInterfaceDeclInfo extends Structure<CXIdxObjCInterfaceDeclInfo, CXIdxObjCInterfaceDeclInfo.ByValue, CXIdxObjCInterfaceDeclInfo.ByReference > {
		/** C type : const CXIdxObjCContainerDeclInfo* */
		public ClangLibrary.CXIdxObjCContainerDeclInfo.ByReference containerInfo;
		/** C type : const CXIdxBaseClassInfo* */
		public ClangLibrary.CXIdxBaseClassInfo.ByReference superInfo;
		/** C type : const CXIdxObjCProtocolRefListInfo* */
		public ClangLibrary.CXIdxObjCProtocolRefListInfo.ByReference protocols;
		public CXIdxObjCInterfaceDeclInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("containerInfo", "superInfo", "protocols");
		}
		/**
		 * @param containerInfo C type : const CXIdxObjCContainerDeclInfo*<br>
		 * @param superInfo C type : const CXIdxBaseClassInfo*<br>
		 * @param protocols C type : const CXIdxObjCProtocolRefListInfo*
		 */
		public CXIdxObjCInterfaceDeclInfo(ClangLibrary.CXIdxObjCContainerDeclInfo.ByReference containerInfo, ClangLibrary.CXIdxBaseClassInfo.ByReference superInfo, ClangLibrary.CXIdxObjCProtocolRefListInfo.ByReference protocols) {
			super();
			this.containerInfo = containerInfo;
			this.superInfo = superInfo;
			this.protocols = protocols;
		}
		public CXIdxObjCInterfaceDeclInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxObjCInterfaceDeclInfo newInstance() { return new CXIdxObjCInterfaceDeclInfo(); }
		public static CXIdxObjCInterfaceDeclInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxObjCInterfaceDeclInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxObjCInterfaceDeclInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxObjCInterfaceDeclInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxObjCCategoryDeclInfo extends Structure<CXIdxObjCCategoryDeclInfo, CXIdxObjCCategoryDeclInfo.ByValue, CXIdxObjCCategoryDeclInfo.ByReference > {
		/** C type : const CXIdxObjCContainerDeclInfo* */
		public ClangLibrary.CXIdxObjCContainerDeclInfo.ByReference containerInfo;
		/** C type : const CXIdxEntityInfo* */
		public ClangLibrary.CXIdxEntityInfo.ByReference objcClass;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor classCursor;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc classLoc;
		/** C type : const CXIdxObjCProtocolRefListInfo* */
		public ClangLibrary.CXIdxObjCProtocolRefListInfo.ByReference protocols;
		public CXIdxObjCCategoryDeclInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("containerInfo", "objcClass", "classCursor", "classLoc", "protocols");
		}
		/**
		 * @param containerInfo C type : const CXIdxObjCContainerDeclInfo*<br>
		 * @param objcClass C type : const CXIdxEntityInfo*<br>
		 * @param classCursor C type : CXCursor<br>
		 * @param classLoc C type : CXIdxLoc<br>
		 * @param protocols C type : const CXIdxObjCProtocolRefListInfo*
		 */
		public CXIdxObjCCategoryDeclInfo(ClangLibrary.CXIdxObjCContainerDeclInfo.ByReference containerInfo, ClangLibrary.CXIdxEntityInfo.ByReference objcClass, ClangLibrary.CXCursor classCursor, ClangLibrary.CXIdxLoc classLoc, ClangLibrary.CXIdxObjCProtocolRefListInfo.ByReference protocols) {
			super();
			this.containerInfo = containerInfo;
			this.objcClass = objcClass;
			this.classCursor = classCursor;
			this.classLoc = classLoc;
			this.protocols = protocols;
		}
		public CXIdxObjCCategoryDeclInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxObjCCategoryDeclInfo newInstance() { return new CXIdxObjCCategoryDeclInfo(); }
		public static CXIdxObjCCategoryDeclInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxObjCCategoryDeclInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxObjCCategoryDeclInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxObjCCategoryDeclInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h:5202</i> */
	public static class struct1 extends Structure<struct1, struct1.ByValue, struct1.ByReference > {
		/** C type : const CXIdxDeclInfo* */
		public ClangLibrary.CXIdxDeclInfo.ByReference declInfo;
		public struct1() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("declInfo");
		}
		/** @param declInfo C type : const CXIdxDeclInfo* */
		public struct1(ClangLibrary.CXIdxDeclInfo.ByReference declInfo) {
			super();
			this.declInfo = declInfo;
		}
		public struct1(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected struct1 newInstance() { return new struct1(); }
		public static struct1[] newArray(int arrayLength) {
			return Structure.newArray(struct1.class, arrayLength);
		}
		public static class ByReference extends struct1 implements Structure.ByReference {
			
		};
		public static class ByValue extends struct1 implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxCXXClassDeclInfo extends Structure<CXIdxCXXClassDeclInfo, CXIdxCXXClassDeclInfo.ByValue, CXIdxCXXClassDeclInfo.ByReference > {
		/** C type : const CXIdxDeclInfo* */
		public ClangLibrary.CXIdxDeclInfo.ByReference declInfo;
		/** C type : const CXIdxBaseClassInfo** */
		public ClangLibrary.CXIdxBaseClassInfo.ByReference[] bases;
		public int numBases;
		public CXIdxCXXClassDeclInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("declInfo", "bases", "numBases");
		}
		/**
		 * @param declInfo C type : const CXIdxDeclInfo*<br>
		 * @param bases C type : const CXIdxBaseClassInfo**
		 */
		public CXIdxCXXClassDeclInfo(ClangLibrary.CXIdxDeclInfo.ByReference declInfo, ClangLibrary.CXIdxBaseClassInfo.ByReference bases[], int numBases) {
			super();
			this.declInfo = declInfo;
			if ((bases.length != this.bases.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.bases = bases;
			this.numBases = numBases;
		}
		public CXIdxCXXClassDeclInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxCXXClassDeclInfo newInstance() { return new CXIdxCXXClassDeclInfo(); }
		public static CXIdxCXXClassDeclInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxCXXClassDeclInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxCXXClassDeclInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxCXXClassDeclInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class CXIdxEntityRefInfo extends Structure<CXIdxEntityRefInfo, CXIdxEntityRefInfo.ByValue, CXIdxEntityRefInfo.ByReference > {
		/**
		 * @see CXIdxEntityRefKind<br>
		 * C type : CXIdxEntityRefKind
		 */
		public int kind;
		/** C type : CXCursor */
		public ClangLibrary.CXCursor cursor;
		/** C type : CXIdxLoc */
		public ClangLibrary.CXIdxLoc loc;
		/** C type : const CXIdxEntityInfo* */
		public ClangLibrary.CXIdxEntityInfo.ByReference referencedEntity;
		/** C type : const CXIdxEntityInfo* */
		public ClangLibrary.CXIdxEntityInfo.ByReference parentEntity;
		/** C type : const CXIdxContainerInfo* */
		public ClangLibrary.CXIdxContainerInfo.ByReference container;
		public CXIdxEntityRefInfo() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("kind", "cursor", "loc", "referencedEntity", "parentEntity", "container");
		}
		/**
		 * @param kind @see CXIdxEntityRefKind<br>
		 * C type : CXIdxEntityRefKind<br>
		 * @param cursor C type : CXCursor<br>
		 * @param loc C type : CXIdxLoc<br>
		 * @param referencedEntity C type : const CXIdxEntityInfo*<br>
		 * @param parentEntity C type : const CXIdxEntityInfo*<br>
		 * @param container C type : const CXIdxContainerInfo*
		 */
		public CXIdxEntityRefInfo(int kind, ClangLibrary.CXCursor cursor, ClangLibrary.CXIdxLoc loc, ClangLibrary.CXIdxEntityInfo.ByReference referencedEntity, ClangLibrary.CXIdxEntityInfo.ByReference parentEntity, ClangLibrary.CXIdxContainerInfo.ByReference container) {
			super();
			this.kind = kind;
			this.cursor = cursor;
			this.loc = loc;
			this.referencedEntity = referencedEntity;
			this.parentEntity = parentEntity;
			this.container = container;
		}
		public CXIdxEntityRefInfo(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXIdxEntityRefInfo newInstance() { return new CXIdxEntityRefInfo(); }
		public static CXIdxEntityRefInfo[] newArray(int arrayLength) {
			return Structure.newArray(CXIdxEntityRefInfo.class, arrayLength);
		}
		public static class ByReference extends CXIdxEntityRefInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends CXIdxEntityRefInfo implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public static class IndexerCallbacks extends Structure<IndexerCallbacks, IndexerCallbacks.ByValue, IndexerCallbacks.ByReference > {
		/** C type : abortQuery_callback* */
		public ClangLibrary.IndexerCallbacks.abortQuery_callback abortQuery;
		/** C type : diagnostic_callback* */
		public ClangLibrary.IndexerCallbacks.diagnostic_callback diagnostic;
		/** C type : enteredMainFile_callback* */
		public ClangLibrary.IndexerCallbacks.enteredMainFile_callback enteredMainFile;
		/** C type : ppIncludedFile_callback* */
		public ClangLibrary.IndexerCallbacks.ppIncludedFile_callback ppIncludedFile;
		/** C type : importedASTFile_callback* */
		public ClangLibrary.IndexerCallbacks.importedASTFile_callback importedASTFile;
		/** C type : startedTranslationUnit_callback* */
		public ClangLibrary.IndexerCallbacks.startedTranslationUnit_callback startedTranslationUnit;
		/** C type : indexDeclaration_callback* */
		public ClangLibrary.IndexerCallbacks.indexDeclaration_callback indexDeclaration;
		/** C type : indexEntityReference_callback* */
		public ClangLibrary.IndexerCallbacks.indexEntityReference_callback indexEntityReference;
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface abortQuery_callback extends Callback {
			int apply(Pointer client_data, Pointer reserved);
		};
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface diagnostic_callback extends Callback {
			void apply(Pointer client_data, Pointer CXDiagnosticSet1, Pointer reserved);
		};
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface enteredMainFile_callback extends Callback {
			Pointer apply(Pointer client_data, Pointer mainFile, Pointer reserved);
		};
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface ppIncludedFile_callback extends Callback {
			Pointer apply(Pointer client_data, ClangLibrary.CXIdxIncludedFileInfo CXIdxIncludedFileInfoPtr1);
		};
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface importedASTFile_callback extends Callback {
			Pointer apply(Pointer client_data, ClangLibrary.CXIdxImportedASTFileInfo CXIdxImportedASTFileInfoPtr1);
		};
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface startedTranslationUnit_callback extends Callback {
			Pointer apply(Pointer client_data, Pointer reserved);
		};
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface indexDeclaration_callback extends Callback {
			void apply(Pointer client_data, ClangLibrary.CXIdxDeclInfo CXIdxDeclInfoPtr1);
		};
		/** <i>native declaration : clang-c/Index.h</i> */
		public interface indexEntityReference_callback extends Callback {
			void apply(Pointer client_data, ClangLibrary.CXIdxEntityRefInfo CXIdxEntityRefInfoPtr1);
		};
		public IndexerCallbacks() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("abortQuery", "diagnostic", "enteredMainFile", "ppIncludedFile", "importedASTFile", "startedTranslationUnit", "indexDeclaration", "indexEntityReference");
		}
		/**
		 * @param abortQuery C type : abortQuery_callback*<br>
		 * @param diagnostic C type : diagnostic_callback*<br>
		 * @param enteredMainFile C type : enteredMainFile_callback*<br>
		 * @param ppIncludedFile C type : ppIncludedFile_callback*<br>
		 * @param importedASTFile C type : importedASTFile_callback*<br>
		 * @param startedTranslationUnit C type : startedTranslationUnit_callback*<br>
		 * @param indexDeclaration C type : indexDeclaration_callback*<br>
		 * @param indexEntityReference C type : indexEntityReference_callback*
		 */
		public IndexerCallbacks(ClangLibrary.IndexerCallbacks.abortQuery_callback abortQuery, ClangLibrary.IndexerCallbacks.diagnostic_callback diagnostic, ClangLibrary.IndexerCallbacks.enteredMainFile_callback enteredMainFile, ClangLibrary.IndexerCallbacks.ppIncludedFile_callback ppIncludedFile, ClangLibrary.IndexerCallbacks.importedASTFile_callback importedASTFile, ClangLibrary.IndexerCallbacks.startedTranslationUnit_callback startedTranslationUnit, ClangLibrary.IndexerCallbacks.indexDeclaration_callback indexDeclaration, ClangLibrary.IndexerCallbacks.indexEntityReference_callback indexEntityReference) {
			super();
			this.abortQuery = abortQuery;
			this.diagnostic = diagnostic;
			this.enteredMainFile = enteredMainFile;
			this.ppIncludedFile = ppIncludedFile;
			this.importedASTFile = importedASTFile;
			this.startedTranslationUnit = startedTranslationUnit;
			this.indexDeclaration = indexDeclaration;
			this.indexEntityReference = indexEntityReference;
		}
		public IndexerCallbacks(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected IndexerCallbacks newInstance() { return new IndexerCallbacks(); }
		public static IndexerCallbacks[] newArray(int arrayLength) {
			return Structure.newArray(IndexerCallbacks.class, arrayLength);
		}
		public static class ByReference extends IndexerCallbacks implements Structure.ByReference {
			
		};
		public static class ByValue extends IndexerCallbacks implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Documentation.h</i> */
	public static class CXComment extends Structure<CXComment, CXComment.ByValue, CXComment.ByReference > {
		/** C type : const void* */
		public Pointer ASTNode;
		/** C type : CXTranslationUnit */
		public ClangLibrary.CXTranslationUnit TranslationUnit;
		public CXComment() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("ASTNode", "TranslationUnit");
		}
		/**
		 * @param ASTNode C type : const void*<br>
		 * @param TranslationUnit C type : CXTranslationUnit
		 */
		public CXComment(Pointer ASTNode, ClangLibrary.CXTranslationUnit TranslationUnit) {
			super();
			this.ASTNode = ASTNode;
			this.TranslationUnit = TranslationUnit;
		}
		public CXComment(Pointer peer) {
			super(peer);
		}
		protected ByReference newByReference() { return new ByReference(); }
		protected ByValue newByValue() { return new ByValue(); }
		protected CXComment newInstance() { return new CXComment(); }
		public static CXComment[] newArray(int arrayLength) {
			return Structure.newArray(CXComment.class, arrayLength);
		}
		public static class ByReference extends CXComment implements Structure.ByReference {
			
		};
		public static class ByValue extends CXComment implements Structure.ByValue {
			
		};
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public interface CXCursorVisitor extends Callback {
		int apply(ClangLibrary.CXCursor.ByValue cursor, ClangLibrary.CXCursor.ByValue parent, Pointer client_data);
	};
	/** <i>native declaration : clang-c/Index.h</i> */
	public interface CXInclusionVisitor extends Callback {
		void apply(Pointer included_file, ClangLibrary.CXSourceLocation inclusion_stack, int include_len, Pointer client_data);
	};
	/** <i>native declaration : clang-c/Index.h:4033</i> */
	public interface clang_executeOnThread_fn_callback extends Callback {
		void apply(Pointer voidPtr1);
	};
	/**
	 * \brief Retrieve the character data associated with the given string.<br>
	 * Original signature : <code>char* clang_getCString(CXString)</code><br>
	 * <i>native declaration : clang-c/CXString.h:29</i>
	 */
	String clang_getCString(ClangLibrary.CXString.ByValue string);
	/**
	 * \brief Free the given string.<br>
	 * Original signature : <code>void clang_disposeString(CXString)</code><br>
	 * <i>native declaration : clang-c/CXString.h:34</i>
	 */
	void clang_disposeString(ClangLibrary.CXString.ByValue string);
	/**
	 * \brief Return the timestamp for use with Clang's<br>
	 * \c -fbuild-session-timestamp= option.<br>
	 * Original signature : <code>long long clang_getBuildSessionTimestamp()</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:15</i>
	 */
	long clang_getBuildSessionTimestamp();
	/**
	 * \brief Create a \c CXVirtualFileOverlay object.<br>
	 * Must be disposed with \c clang_VirtualFileOverlay_dispose().<br>
	 * \param options is reserved, always pass 0.<br>
	 * Original signature : <code>CXVirtualFileOverlay clang_VirtualFileOverlay_create(unsigned)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:29</i>
	 */
	ClangLibrary.CXVirtualFileOverlay clang_VirtualFileOverlay_create(int options);
	/**
	 * \brief Map an absolute virtual file path to an absolute real one.<br>
	 * The virtual path must be canonicalized (not contain "."/"..").<br>
	 * \returns 0 for success, non-zero to indicate an error.<br>
	 * Original signature : <code>CXErrorCode clang_VirtualFileOverlay_addFileMapping(CXVirtualFileOverlay, const char*, const char*)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:37</i>
	 */
	int clang_VirtualFileOverlay_addFileMapping(ClangLibrary.CXVirtualFileOverlay CXVirtualFileOverlay1, String virtualPath, String realPath);
	/**
	 * \brief Set the case sensitivity for the \c CXVirtualFileOverlay object.<br>
	 * The \c CXVirtualFileOverlay object is case-sensitive by default, this<br>
	 * option can be used to override the default.<br>
	 * \returns 0 for success, non-zero to indicate an error.<br>
	 * Original signature : <code>CXErrorCode clang_VirtualFileOverlay_setCaseSensitivity(CXVirtualFileOverlay, int)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:48</i>
	 */
	int clang_VirtualFileOverlay_setCaseSensitivity(ClangLibrary.CXVirtualFileOverlay CXVirtualFileOverlay1, int caseSensitive);
	/**
	 * \brief Write out the \c CXVirtualFileOverlay object to a char buffer.<br>
	 * \param options is reserved, always pass 0.<br>
	 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be<br>
	 * disposed using \c free().<br>
	 * \param out_buffer_size pointer to receive the buffer size.<br>
	 * \returns 0 for success, non-zero to indicate an error.<br>
	 * Original signature : <code>CXErrorCode clang_VirtualFileOverlay_writeToBuffer(CXVirtualFileOverlay, unsigned, char**, unsigned*)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:61</i>
	 */
	int clang_VirtualFileOverlay_writeToBuffer(ClangLibrary.CXVirtualFileOverlay CXVirtualFileOverlay1, int options, PointerByReference out_buffer_ptr, IntBuffer out_buffer_size);
	/**
	 * \brief Dispose a \c CXVirtualFileOverlay object.<br>
	 * Original signature : <code>void clang_VirtualFileOverlay_dispose(CXVirtualFileOverlay)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:69</i>
	 */
	void clang_VirtualFileOverlay_dispose(ClangLibrary.CXVirtualFileOverlay CXVirtualFileOverlay1);
	/**
	 * \brief Create a \c CXModuleMapDescriptor object.<br>
	 * Must be disposed with \c clang_ModuleMapDescriptor_dispose().<br>
	 * \param options is reserved, always pass 0.<br>
	 * Original signature : <code>CXModuleMapDescriptor clang_ModuleMapDescriptor_create(unsigned)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:82</i>
	 */
	ClangLibrary.CXModuleMapDescriptor clang_ModuleMapDescriptor_create(int options);
	/**
	 * \brief Sets the framework module name that the module.map describes.<br>
	 * \returns 0 for success, non-zero to indicate an error.<br>
	 * Original signature : <code>CXErrorCode clang_ModuleMapDescriptor_setFrameworkModuleName(CXModuleMapDescriptor, const char*)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:89</i>
	 */
	int clang_ModuleMapDescriptor_setFrameworkModuleName(ClangLibrary.CXModuleMapDescriptor CXModuleMapDescriptor1, String name);
	/**
	 * \brief Sets the umbrealla header name that the module.map describes.<br>
	 * \returns 0 for success, non-zero to indicate an error.<br>
	 * Original signature : <code>CXErrorCode clang_ModuleMapDescriptor_setUmbrellaHeader(CXModuleMapDescriptor, const char*)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:97</i>
	 */
	int clang_ModuleMapDescriptor_setUmbrellaHeader(ClangLibrary.CXModuleMapDescriptor CXModuleMapDescriptor1, String name);
	/**
	 * \brief Write out the \c CXModuleMapDescriptor object to a char buffer.<br>
	 * \param options is reserved, always pass 0.<br>
	 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be<br>
	 * disposed using \c free().<br>
	 * \param out_buffer_size pointer to receive the buffer size.<br>
	 * \returns 0 for success, non-zero to indicate an error.<br>
	 * Original signature : <code>CXErrorCode clang_ModuleMapDescriptor_writeToBuffer(CXModuleMapDescriptor, unsigned, char**, unsigned*)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:110</i>
	 */
	int clang_ModuleMapDescriptor_writeToBuffer(ClangLibrary.CXModuleMapDescriptor CXModuleMapDescriptor1, int options, PointerByReference out_buffer_ptr, IntBuffer out_buffer_size);
	/**
	 * \brief Dispose a \c CXModuleMapDescriptor object.<br>
	 * Original signature : <code>void clang_ModuleMapDescriptor_dispose(CXModuleMapDescriptor)</code><br>
	 * <i>native declaration : clang-c/BuildSystem.h:118</i>
	 */
	void clang_ModuleMapDescriptor_dispose(ClangLibrary.CXModuleMapDescriptor CXModuleMapDescriptor1);
	/**
	 * \brief Provides a shared context for creating translation units.<br>
	 * It provides two options:<br>
	 * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"<br>
	 * declarations (when loading any new translation units). A "local" declaration<br>
	 * is one that belongs in the translation unit itself and not in a precompiled<br>
	 * header that was used by the translation unit. If zero, all declarations<br>
	 * will be enumerated.<br>
	 * Here is an example:<br>
	 * \code<br>
	 *   // excludeDeclsFromPCH = 1, displayDiagnostics=1<br>
	 *   Idx = clang_createIndex(1, 1);<br>
	 *   // IndexTest.pch was produced with the following command:<br>
	 *   // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"<br>
	 *   TU = clang_createTranslationUnit(Idx, "IndexTest.pch");<br>
	 *   // This will load all the symbols from 'IndexTest.pch'<br>
	 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),<br>
	 *                       TranslationUnitVisitor, 0);<br>
	 *   clang_disposeTranslationUnit(TU);<br>
	 *   // This will load all the symbols from 'IndexTest.c', excluding symbols<br>
	 *   // from 'IndexTest.pch'.<br>
	 *   char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };<br>
	 *   TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,<br>
	 *                                                  0, 0);<br>
	 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),<br>
	 *                       TranslationUnitVisitor, 0);<br>
	 *   clang_disposeTranslationUnit(TU);<br>
	 * \endcode<br>
	 * This process of creating the 'pch', loading it separately, and using it (via<br>
	 * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks<br>
	 * (which gives the indexer the same performance benefit as the compiler).<br>
	 * Original signature : <code>CXIndex clang_createIndex(int, int)</code><br>
	 * <i>native declaration : clang-c/Index.h:208</i>
	 */
	Pointer clang_createIndex(int excludeDeclarationsFromPCH, int displayDiagnostics);
	/**
	 * \brief Destroy the given index.<br>
	 * The index must not be destroyed until all of the translation units created<br>
	 * within that index have been destroyed.<br>
	 * Original signature : <code>void clang_disposeIndex(CXIndex)</code><br>
	 * <i>native declaration : clang-c/Index.h:217</i>
	 */
	void clang_disposeIndex(Pointer index);
	/**
	 * \brief Sets general options associated with a CXIndex.<br>
	 * For example:<br>
	 * \code<br>
	 * CXIndex idx = ...;<br>
	 * clang_CXIndex_setGlobalOptions(idx,<br>
	 *     clang_CXIndex_getGlobalOptions(idx) |<br>
	 *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);<br>
	 * \endcode<br>
	 * \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.<br>
	 * Original signature : <code>void clang_CXIndex_setGlobalOptions(CXIndex, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:266</i>
	 */
	void clang_CXIndex_setGlobalOptions(Pointer CXIndex1, int options);
	/**
	 * \brief Gets the general options associated with a CXIndex.<br>
	 * \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that<br>
	 * are associated with the given CXIndex object.<br>
	 * Original signature : <code>int clang_CXIndex_getGlobalOptions(CXIndex)</code><br>
	 * <i>native declaration : clang-c/Index.h:274</i>
	 */
	int clang_CXIndex_getGlobalOptions(Pointer CXIndex1);
	/**
	 * \brief Retrieve the complete file and path name of the given file.<br>
	 * Original signature : <code>CXString clang_getFileName(CXFile)</code><br>
	 * <i>native declaration : clang-c/Index.h:291</i>
	 */
	ClangLibrary.CXString.ByValue clang_getFileName(Pointer SFile);
	/**
	 * \brief Retrieve the last modification time of the given file.<br>
	 * Original signature : <code>time_t clang_getFileTime(CXFile)</code><br>
	 * <i>native declaration : clang-c/Index.h:296</i>
	 */
	 // clang_getFileTime(Pointer SFile);
	/**
	 * \brief Retrieve the unique ID for the given \c file.<br>
	 * \param file the file to get the ID for.<br>
	 * \param outID stores the returned CXFileUniqueID.<br>
	 * \returns If there was a failure getting the unique ID, returns non-zero,<br>
	 * otherwise returns 0.<br>
	 * Original signature : <code>int clang_getFileUniqueID(CXFile, CXFileUniqueID*)</code><br>
	 * <i>native declaration : clang-c/Index.h:314</i>
	 */
	int clang_getFileUniqueID(Pointer file, ClangLibrary.CXFileUniqueID outID);
	/**
	 * \brief Determine whether the given header is guarded against<br>
	 * multiple inclusions, either with the conventional<br>
	 * \#ifndef/\#define/\#endif macro guards or with \#pragma once.<br>
	 * Original signature : <code>int clang_isFileMultipleIncludeGuarded(CXTranslationUnit, CXFile)</code><br>
	 * <i>native declaration : clang-c/Index.h:321</i>
	 */
	int clang_isFileMultipleIncludeGuarded(ClangLibrary.CXTranslationUnit tu, Pointer file);
	/**
	 * \brief Retrieve a file handle within the given translation unit.<br>
	 * \param tu the translation unit<br>
	 * \param file_name the name of the file.<br>
	 * \returns the file handle for the named file in the translation unit \p tu,<br>
	 * or a NULL file handle if the file was not a part of this translation unit.<br>
	 * Original signature : <code>CXFile clang_getFile(CXTranslationUnit, const char*)</code><br>
	 * <i>native declaration : clang-c/Index.h:334</i>
	 */
	Pointer clang_getFile(ClangLibrary.CXTranslationUnit tu, String file_name);
	/**
	 * \brief Returns non-zero if the \c file1 and \c file2 point to the same file,<br>
	 * or they are both NULL.<br>
	 * Original signature : <code>int clang_File_isEqual(CXFile, CXFile)</code><br>
	 * <i>native declaration : clang-c/Index.h:341</i>
	 */
	int clang_File_isEqual(Pointer file1, Pointer file2);
	/**
	 * \brief Retrieve a NULL (invalid) source location.<br>
	 * Original signature : <code>CXSourceLocation clang_getNullLocation()</code><br>
	 * <i>native declaration : clang-c/Index.h:387</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getNullLocation();
	/**
	 * \brief Determine whether two source locations, which must refer into<br>
	 * the same translation unit, refer to exactly the same point in the source<br>
	 * code.<br>
	 * \returns non-zero if the source locations refer to the same location, zero<br>
	 * if they refer to different locations.<br>
	 * Original signature : <code>int clang_equalLocations(CXSourceLocation, CXSourceLocation)</code><br>
	 * <i>native declaration : clang-c/Index.h:397</i>
	 */
	int clang_equalLocations(ClangLibrary.CXSourceLocation.ByValue loc1, ClangLibrary.CXSourceLocation.ByValue loc2);
	/**
	 * \brief Retrieves the source location associated with a given file/line/column<br>
	 * in a particular translation unit.<br>
	 * Original signature : <code>CXSourceLocation clang_getLocation(CXTranslationUnit, CXFile, unsigned, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:404</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getLocation(ClangLibrary.CXTranslationUnit tu, Pointer file, int line, int column);
	/**
	 * \brief Retrieves the source location associated with a given character offset<br>
	 * in a particular translation unit.<br>
	 * Original signature : <code>CXSourceLocation clang_getLocationForOffset(CXTranslationUnit, CXFile, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:412</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getLocationForOffset(ClangLibrary.CXTranslationUnit tu, Pointer file, int offset);
	/**
	 * \brief Returns non-zero if the given source location is in a system header.<br>
	 * Original signature : <code>int clang_Location_isInSystemHeader(CXSourceLocation)</code><br>
	 * <i>native declaration : clang-c/Index.h:419</i>
	 */
	int clang_Location_isInSystemHeader(ClangLibrary.CXSourceLocation.ByValue location);
	/**
	 * \brief Returns non-zero if the given source location is in the main file of<br>
	 * the corresponding translation unit.<br>
	 * Original signature : <code>int clang_Location_isFromMainFile(CXSourceLocation)</code><br>
	 * <i>native declaration : clang-c/Index.h:425</i>
	 */
	int clang_Location_isFromMainFile(ClangLibrary.CXSourceLocation.ByValue location);
	/**
	 * \brief Retrieve a NULL (invalid) source range.<br>
	 * Original signature : <code>CXSourceRange clang_getNullRange()</code><br>
	 * <i>native declaration : clang-c/Index.h:430</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_getNullRange();
	/**
	 * \brief Retrieve a source range given the beginning and ending source<br>
	 * locations.<br>
	 * Original signature : <code>CXSourceRange clang_getRange(CXSourceLocation, CXSourceLocation)</code><br>
	 * <i>native declaration : clang-c/Index.h:436</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_getRange(ClangLibrary.CXSourceLocation.ByValue begin, ClangLibrary.CXSourceLocation.ByValue end);
	/**
	 * \brief Determine whether two ranges are equivalent.<br>
	 * \returns non-zero if the ranges are the same, zero if they differ.<br>
	 * Original signature : <code>int clang_equalRanges(CXSourceRange, CXSourceRange)</code><br>
	 * <i>native declaration : clang-c/Index.h:444</i>
	 */
	int clang_equalRanges(ClangLibrary.CXSourceRange.ByValue range1, ClangLibrary.CXSourceRange.ByValue range2);
	/**
	 * \brief Returns non-zero if \p range is null.<br>
	 * Original signature : <code>int clang_Range_isNull(CXSourceRange)</code><br>
	 * <i>native declaration : clang-c/Index.h:450</i>
	 */
	int clang_Range_isNull(ClangLibrary.CXSourceRange.ByValue range);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location.<br>
	 * If the location refers into a macro expansion, retrieves the<br>
	 * location of the macro expansion.<br>
	 * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * \param file [out] if non-NULL, will be set to the file to which the given<br>
	 * source location points.<br>
	 * \param line [out] if non-NULL, will be set to the line to which the given<br>
	 * source location points.<br>
	 * \param column [out] if non-NULL, will be set to the column to which the given<br>
	 * source location points.<br>
	 * \param offset [out] if non-NULL, will be set to the offset into the<br>
	 * buffer to which the given source location points.<br>
	 * Original signature : <code>void clang_getExpansionLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:474</i>
	 */
	void clang_getExpansionLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location, as specified in a # line directive.<br>
	 * Example: given the following source code in a file somefile.c<br>
	 * \code<br>
	 * #123 "dummy.c" 1<br>
	 * static int func(void)<br>
	 * {<br>
	 *     return 0;<br>
	 * }<br>
	 * \endcode<br>
	 * the location information returned by this function would be<br>
	 * File: dummy.c Line: 124 Column: 12<br>
	 * whereas clang_getExpansionLocation would have returned<br>
	 * File: somefile.c Line: 3 Column: 12<br>
	 * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * \param filename [out] if non-NULL, will be set to the filename of the<br>
	 * source location. Note that filenames returned will be for "virtual" files,<br>
	 * which don't necessarily exist on the machine running clang - e.g. when<br>
	 * parsing preprocessed output obtained from a different environment. If<br>
	 * a non-NULL value is passed in, remember to dispose of the returned value<br>
	 * using \c clang_disposeString() once you've finished with it. For an invalid<br>
	 * source location, an empty string is returned.<br>
	 * \param line [out] if non-NULL, will be set to the line number of the<br>
	 * source location. For an invalid source location, zero is returned.<br>
	 * \param column [out] if non-NULL, will be set to the column number of the<br>
	 * source location. For an invalid source location, zero is returned.<br>
	 * Original signature : <code>void clang_getPresumedLocation(CXSourceLocation, CXString*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:520</i>
	 */
	void clang_getPresumedLocation(ClangLibrary.CXSourceLocation.ByValue location, ClangLibrary.CXString filename, IntBuffer line, IntBuffer column);
	/**
	 * \brief Legacy API to retrieve the file, line, column, and offset represented<br>
	 * by the given source location.<br>
	 * This interface has been replaced by the newer interface<br>
	 * #clang_getExpansionLocation(). See that interface's documentation for<br>
	 * details.<br>
	 * Original signature : <code>void clang_getInstantiationLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:533</i>
	 */
	void clang_getInstantiationLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location.<br>
	 * If the location refers into a macro instantiation, return where the<br>
	 * location was originally spelled in the source file.<br>
	 * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * \param file [out] if non-NULL, will be set to the file to which the given<br>
	 * source location points.<br>
	 * \param line [out] if non-NULL, will be set to the line to which the given<br>
	 * source location points.<br>
	 * \param column [out] if non-NULL, will be set to the column to which the given<br>
	 * source location points.<br>
	 * \param offset [out] if non-NULL, will be set to the offset into the<br>
	 * buffer to which the given source location points.<br>
	 * Original signature : <code>void clang_getSpellingLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:561</i>
	 */
	void clang_getSpellingLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve the file, line, column, and offset represented by<br>
	 * the given source location.<br>
	 * If the location refers into a macro expansion, return where the macro was<br>
	 * expanded or where the macro argument was written, if the location points at<br>
	 * a macro argument.<br>
	 * \param location the location within a source file that will be decomposed<br>
	 * into its parts.<br>
	 * \param file [out] if non-NULL, will be set to the file to which the given<br>
	 * source location points.<br>
	 * \param line [out] if non-NULL, will be set to the line to which the given<br>
	 * source location points.<br>
	 * \param column [out] if non-NULL, will be set to the column to which the given<br>
	 * source location points.<br>
	 * \param offset [out] if non-NULL, will be set to the offset into the<br>
	 * buffer to which the given source location points.<br>
	 * Original signature : <code>void clang_getFileLocation(CXSourceLocation, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:590</i>
	 */
	void clang_getFileLocation(ClangLibrary.CXSourceLocation.ByValue location, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve a source location representing the first character within a<br>
	 * source range.<br>
	 * Original signature : <code>CXSourceLocation clang_getRangeStart(CXSourceRange)</code><br>
	 * <i>native declaration : clang-c/Index.h:600</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getRangeStart(ClangLibrary.CXSourceRange.ByValue range);
	/**
	 * \brief Retrieve a source location representing the last character within a<br>
	 * source range.<br>
	 * Original signature : <code>CXSourceLocation clang_getRangeEnd(CXSourceRange)</code><br>
	 * <i>native declaration : clang-c/Index.h:606</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getRangeEnd(ClangLibrary.CXSourceRange.ByValue range);
	/**
	 * \brief Retrieve all ranges that were skipped by the preprocessor.<br>
	 * The preprocessor will skip lines when they are surrounded by an<br>
	 * if/ifdef/ifndef directive whose condition does not evaluate to true.<br>
	 * Original signature : <code>CXSourceRangeList* clang_getSkippedRanges(CXTranslationUnit, CXFile)</code><br>
	 * <i>native declaration : clang-c/Index.h:626</i>
	 */
	ClangLibrary.CXSourceRangeList clang_getSkippedRanges(ClangLibrary.CXTranslationUnit tu, Pointer file);
	/**
	 * \brief Destroy the given \c CXSourceRangeList.<br>
	 * Original signature : <code>void clang_disposeSourceRangeList(CXSourceRangeList*)</code><br>
	 * <i>native declaration : clang-c/Index.h:632</i>
	 */
	void clang_disposeSourceRangeList(ClangLibrary.CXSourceRangeList ranges);
	/**
	 * \brief Determine the number of diagnostics in a CXDiagnosticSet.<br>
	 * Original signature : <code>int clang_getNumDiagnosticsInSet(CXDiagnosticSet)</code><br>
	 * <i>native declaration : clang-c/Index.h:693</i>
	 */
	int clang_getNumDiagnosticsInSet(Pointer Diags);
	/**
	 * \brief Retrieve a diagnostic associated with the given CXDiagnosticSet.<br>
	 * \param Diags the CXDiagnosticSet to query.<br>
	 * \param Index the zero-based diagnostic number to retrieve.<br>
	 * \returns the requested diagnostic. This diagnostic must be freed<br>
	 * via a call to \c clang_disposeDiagnostic().<br>
	 * Original signature : <code>CXDiagnostic clang_getDiagnosticInSet(CXDiagnosticSet, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:704</i>
	 */
	Pointer clang_getDiagnosticInSet(Pointer Diags, int Index);
	/**
	 * \brief Deserialize a set of diagnostics from a Clang diagnostics bitcode<br>
	 * file.<br>
	 * \param file The name of the file to deserialize.<br>
	 * \param error A pointer to a enum value recording if there was a problem<br>
	 *        deserializing the diagnostics.<br>
	 * \param errorString A pointer to a CXString for recording the error string<br>
	 *        if the file was not successfully loaded.<br>
	 * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These<br>
	 * diagnostics should be released using clang_disposeDiagnosticSet().<br>
	 * Original signature : <code>CXDiagnosticSet clang_loadDiagnostics(const char*, CXLoadDiag_Error*, CXString*)</code><br>
	 * <i>native declaration : clang-c/Index.h:750</i>
	 */
	Pointer clang_loadDiagnostics(String file, IntBuffer error, ClangLibrary.CXString errorString);
	/**
	 * \brief Release a CXDiagnosticSet and all of its contained diagnostics.<br>
	 * Original signature : <code>void clang_disposeDiagnosticSet(CXDiagnosticSet)</code><br>
	 * <i>native declaration : clang-c/Index.h:757</i>
	 */
	void clang_disposeDiagnosticSet(Pointer Diags);
	/**
	 * \brief Retrieve the child diagnostics of a CXDiagnostic. <br>
	 * This CXDiagnosticSet does not need to be released by<br>
	 * clang_disposeDiagnosticSet.<br>
	 * Original signature : <code>CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:765</i>
	 */
	Pointer clang_getChildDiagnostics(Pointer D);
	/**
	 * \brief Determine the number of diagnostics produced for the given<br>
	 * translation unit.<br>
	 * Original signature : <code>int clang_getNumDiagnostics(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:771</i>
	 */
	int clang_getNumDiagnostics(ClangLibrary.CXTranslationUnit Unit);
	/**
	 * \brief Retrieve a diagnostic associated with the given translation unit.<br>
	 * \param Unit the translation unit to query.<br>
	 * \param Index the zero-based diagnostic number to retrieve.<br>
	 * \returns the requested diagnostic. This diagnostic must be freed<br>
	 * via a call to \c clang_disposeDiagnostic().<br>
	 * Original signature : <code>CXDiagnostic clang_getDiagnostic(CXTranslationUnit, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:782</i>
	 */
	Pointer clang_getDiagnostic(ClangLibrary.CXTranslationUnit Unit, int Index);
	/**
	 * \brief Retrieve the complete set of diagnostics associated with a<br>
	 *        translation unit.<br>
	 * \param Unit the translation unit to query.<br>
	 * Original signature : <code>CXDiagnosticSet clang_getDiagnosticSetFromTU(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:791</i>
	 */
	Pointer clang_getDiagnosticSetFromTU(ClangLibrary.CXTranslationUnit Unit);
	/**
	 * \brief Destroy a diagnostic.<br>
	 * Original signature : <code>void clang_disposeDiagnostic(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:797</i>
	 */
	void clang_disposeDiagnostic(Pointer Diagnostic);
	/**
	 * \brief Format the given diagnostic in a manner that is suitable for display.<br>
	 * This routine will format the given diagnostic to a string, rendering<br>
	 * the diagnostic according to the various options given. The<br>
	 * \c clang_defaultDiagnosticDisplayOptions() function returns the set of<br>
	 * options that most closely mimics the behavior of the clang compiler.<br>
	 * \param Diagnostic The diagnostic to print.<br>
	 * \param Options A set of options that control the diagnostic display,<br>
	 * created by combining \c CXDiagnosticDisplayOptions values.<br>
	 * \returns A new string containing for formatted diagnostic.<br>
	 * Original signature : <code>CXString clang_formatDiagnostic(CXDiagnostic, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:882</i>
	 */
	ClangLibrary.CXString.ByValue clang_formatDiagnostic(Pointer Diagnostic, int Options);
	/**
	 * \brief Retrieve the set of display options most similar to the<br>
	 * default behavior of the clang compiler.<br>
	 * \returns A set of display options suitable for use with \c<br>
	 * clang_formatDiagnostic().<br>
	 * Original signature : <code>int clang_defaultDiagnosticDisplayOptions()</code><br>
	 * <i>native declaration : clang-c/Index.h:892</i>
	 */
	int clang_defaultDiagnosticDisplayOptions();
	/**
	 * \brief Determine the severity of the given diagnostic.<br>
	 * Original signature : <code>CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:897</i>
	 */
	int clang_getDiagnosticSeverity(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve the source location of the given diagnostic.<br>
	 * This location is where Clang would print the caret ('^') when<br>
	 * displaying the diagnostic on the command line.<br>
	 * Original signature : <code>CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:906</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getDiagnosticLocation(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve the text of the given diagnostic.<br>
	 * Original signature : <code>CXString clang_getDiagnosticSpelling(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:911</i>
	 */
	ClangLibrary.CXString.ByValue clang_getDiagnosticSpelling(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve the name of the command-line option that enabled this<br>
	 * diagnostic.<br>
	 * \param Diag The diagnostic to be queried.<br>
	 * \param Disable If non-NULL, will be set to the option that disables this<br>
	 * diagnostic (if any).<br>
	 * \returns A string that contains the command-line option used to enable this<br>
	 * warning, such as "-Wconversion" or "-pedantic".<br>
	 * Original signature : <code>CXString clang_getDiagnosticOption(CXDiagnostic, CXString*)</code><br>
	 * <i>native declaration : clang-c/Index.h:925</i>
	 */
	ClangLibrary.CXString.ByValue clang_getDiagnosticOption(Pointer Diag, ClangLibrary.CXString Disable);
	/**
	 * \brief Retrieve the category number for this diagnostic.<br>
	 * Diagnostics can be categorized into groups along with other, related<br>
	 * diagnostics (e.g., diagnostics under the same warning flag). This routine <br>
	 * retrieves the category number for the given diagnostic.<br>
	 * \returns The number of the category that contains this diagnostic, or zero<br>
	 * if this diagnostic is uncategorized.<br>
	 * Original signature : <code>int clang_getDiagnosticCategory(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:938</i>
	 */
	int clang_getDiagnosticCategory(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve the name of a particular diagnostic category.  This<br>
	 *  is now deprecated.  Use clang_getDiagnosticCategoryText()<br>
	 *  instead.<br>
	 * \param Category A diagnostic category number, as returned by <br>
	 * \c clang_getDiagnosticCategory().<br>
	 * \returns The name of the given diagnostic category.<br>
	 * Original signature : <code>CXString clang_getDiagnosticCategoryName(unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:951</i>
	 */
	ClangLibrary.CXString.ByValue clang_getDiagnosticCategoryName(int Category);
	/**
	 * \brief Retrieve the diagnostic category text for a given diagnostic.<br>
	 * \returns The text of the given diagnostic category.<br>
	 * Original signature : <code>CXString clang_getDiagnosticCategoryText(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:958</i>
	 */
	ClangLibrary.CXString.ByValue clang_getDiagnosticCategoryText(Pointer CXDiagnostic1);
	/**
	 * \brief Determine the number of source ranges associated with the given<br>
	 * diagnostic.<br>
	 * Original signature : <code>int clang_getDiagnosticNumRanges(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:964</i>
	 */
	int clang_getDiagnosticNumRanges(Pointer CXDiagnostic1);
	/**
	 * \brief Retrieve a source range associated with the diagnostic.<br>
	 * A diagnostic's source ranges highlight important elements in the source<br>
	 * code. On the command line, Clang displays source ranges by<br>
	 * underlining them with '~' characters.<br>
	 * \param Diagnostic the diagnostic whose range is being extracted.<br>
	 * \param Range the zero-based index specifying which range to<br>
	 * \returns the requested source range.<br>
	 * Original signature : <code>CXSourceRange clang_getDiagnosticRange(CXDiagnostic, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:979</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_getDiagnosticRange(Pointer Diagnostic, int Range);
	/**
	 * \brief Determine the number of fix-it hints associated with the<br>
	 * given diagnostic.<br>
	 * Original signature : <code>int clang_getDiagnosticNumFixIts(CXDiagnostic)</code><br>
	 * <i>native declaration : clang-c/Index.h:986</i>
	 */
	int clang_getDiagnosticNumFixIts(Pointer Diagnostic);
	/**
	 * \brief Retrieve the replacement information for a given fix-it.<br>
	 * Fix-its are described in terms of a source range whose contents<br>
	 * should be replaced by a string. This approach generalizes over<br>
	 * three kinds of operations: removal of source code (the range covers<br>
	 * the code to be removed and the replacement string is empty),<br>
	 * replacement of source code (the range covers the code to be<br>
	 * replaced and the replacement string provides the new code), and<br>
	 * insertion (both the start and end of the range point at the<br>
	 * insertion location, and the replacement string provides the text to<br>
	 * insert).<br>
	 * \param Diagnostic The diagnostic whose fix-its are being queried.<br>
	 * \param FixIt The zero-based index of the fix-it.<br>
	 * \param ReplacementRange The source range whose contents will be<br>
	 * replaced with the returned replacement string. Note that source<br>
	 * ranges are half-open ranges [a, b), so the source code should be<br>
	 * replaced from a and up to (but not including) b.<br>
	 * \returns A string containing text that should be replace the source<br>
	 * code indicated by the \c ReplacementRange.<br>
	 * Original signature : <code>CXString clang_getDiagnosticFixIt(CXDiagnostic, unsigned, CXSourceRange*)</code><br>
	 * <i>native declaration : clang-c/Index.h:1013</i>
	 */
	ClangLibrary.CXString.ByValue clang_getDiagnosticFixIt(Pointer Diagnostic, int FixIt, ClangLibrary.CXSourceRange ReplacementRange);
	/**
	 * \brief Get the original translation unit source file name.<br>
	 * Original signature : <code>CXString clang_getTranslationUnitSpelling(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:1034</i>
	 */
	ClangLibrary.CXString.ByValue clang_getTranslationUnitSpelling(ClangLibrary.CXTranslationUnit CTUnit);
	/**
	 * \brief Return the CXTranslationUnit for a given source file and the provided<br>
	 * command line arguments one would pass to the compiler.<br>
	 * Note: The 'source_filename' argument is optional.  If the caller provides a<br>
	 * NULL pointer, the name of the source file is expected to reside in the<br>
	 * specified command line arguments.<br>
	 * Note: When encountered in 'clang_command_line_args', the following options<br>
	 * are ignored:<br>
	 *   '-c'<br>
	 *   '-emit-ast'<br>
	 *   '-fsyntax-only'<br>
	 *   '-o \<output file>'  (both '-o' and '\<output file>' are ignored)<br>
	 * \param CIdx The index object with which the translation unit will be<br>
	 * associated.<br>
	 * \param source_filename The name of the source file to load, or NULL if the<br>
	 * source file is included in \p clang_command_line_args.<br>
	 * \param num_clang_command_line_args The number of command-line arguments in<br>
	 * \p clang_command_line_args.<br>
	 * \param clang_command_line_args The command-line arguments that would be<br>
	 * passed to the \c clang executable if it were being invoked out-of-process.<br>
	 * These command-line options will be parsed and will affect how the translation<br>
	 * unit is parsed. Note that the following options are ignored: '-c',<br>
	 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
	 * \param num_unsaved_files the number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * \param unsaved_files the files that have not yet been saved to disk<br>
	 * but may be required for code completion, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * Original signature : <code>CXTranslationUnit clang_createTranslationUnitFromSourceFile(CXIndex, const char*, int, const const char**, unsigned, CXUnsavedFile*)</code><br>
	 * <i>native declaration : clang-c/Index.h:1077</i>
	 */
	ClangLibrary.CXTranslationUnit clang_createTranslationUnitFromSourceFile(Pointer CIdx, String source_filename, int num_clang_command_line_args, String clang_command_line_args[], int num_unsaved_files, ClangLibrary.CXUnsavedFile unsaved_files);
	/**
	 * \brief Same as \c clang_createTranslationUnit2, but returns<br>
	 * the \c CXTranslationUnit instead of an error code.  In case of an error this<br>
	 * routine returns a \c NULL \c CXTranslationUnit, without further detailed<br>
	 * error codes.<br>
	 * Original signature : <code>CXTranslationUnit clang_createTranslationUnit(CXIndex, const char*)</code><br>
	 * <i>native declaration : clang-c/Index.h:1091</i>
	 */
	ClangLibrary.CXTranslationUnit clang_createTranslationUnit(Pointer CIdx, String ast_filename);
	/**
	 * \brief Create a translation unit from an AST file (\c -emit-ast).<br>
	 * \param[out] out_TU A non-NULL pointer to store the created<br>
	 * \c CXTranslationUnit.<br>
	 * \returns Zero on success, otherwise returns an error code.<br>
	 * Original signature : <code>CXErrorCode clang_createTranslationUnit2(CXIndex, const char*, CXTranslationUnit*)</code><br>
	 * <i>native declaration : clang-c/Index.h:1103</i>
	 */
	int clang_createTranslationUnit2(Pointer CIdx, String ast_filename, PointerByReference out_TU);
	/**
	 * \brief Create a translation unit from an AST file (\c -emit-ast).<br>
	 * \param[out] out_TU A non-NULL pointer to store the created<br>
	 * \c CXTranslationUnit.<br>
	 * \returns Zero on success, otherwise returns an error code.<br>
	 * Original signature : <code>CXErrorCode clang_createTranslationUnit2(CXIndex, const char*, CXTranslationUnit*)</code><br>
	 * <i>native declaration : clang-c/Index.h:1103</i>
	 */
	int clang_createTranslationUnit2(Pointer CIdx, Pointer ast_filename, PointerByReference out_TU);
	/**
	 * \brief Returns the set of flags that is suitable for parsing a translation<br>
	 * unit that is being edited.<br>
	 * The set of flags returned provide options for \c clang_parseTranslationUnit()<br>
	 * to indicate that the translation unit is likely to be reparsed many times,<br>
	 * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly<br>
	 * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag<br>
	 * set contains an unspecified set of optimizations (e.g., the precompiled <br>
	 * preamble) geared toward improving the performance of these routines. The<br>
	 * set of optimizations enabled may change from one version to the next.<br>
	 * Original signature : <code>int clang_defaultEditingTranslationUnitOptions()</code><br>
	 * <i>native declaration : clang-c/Index.h:1219</i>
	 */
	int clang_defaultEditingTranslationUnitOptions();
	/**
	 * \brief Same as \c clang_parseTranslationUnit2, but returns<br>
	 * the \c CXTranslationUnit instead of an error code.  In case of an error this<br>
	 * routine returns a \c NULL \c CXTranslationUnit, without further detailed<br>
	 * error codes.<br>
	 * Original signature : <code>CXTranslationUnit clang_parseTranslationUnit(CXIndex, const char*, const const char**, int, CXUnsavedFile*, unsigned, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:1227</i>
	 */
	ClangLibrary.CXTranslationUnit clang_parseTranslationUnit(Pointer CIdx, String source_filename, String command_line_args[], int num_command_line_args, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	/**
	 * \brief Parse the given source file and the translation unit corresponding<br>
	 * to that file.<br>
	 * This routine is the main entry point for the Clang C API, providing the<br>
	 * ability to parse a source file into a translation unit that can then be<br>
	 * queried by other functions in the API. This routine accepts a set of<br>
	 * command-line arguments so that the compilation can be configured in the same<br>
	 * way that the compiler is configured on the command line.<br>
	 * \param CIdx The index object with which the translation unit will be <br>
	 * associated.<br>
	 * \param source_filename The name of the source file to load, or NULL if the<br>
	 * source file is included in \c command_line_args.<br>
	 * \param command_line_args The command-line arguments that would be<br>
	 * passed to the \c clang executable if it were being invoked out-of-process.<br>
	 * These command-line options will be parsed and will affect how the translation<br>
	 * unit is parsed. Note that the following options are ignored: '-c', <br>
	 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
	 * \param num_command_line_args The number of command-line arguments in<br>
	 * \c command_line_args.<br>
	 * \param unsaved_files the files that have not yet been saved to disk<br>
	 * but may be required for parsing, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * \param num_unsaved_files the number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * \param options A bitmask of options that affects how the translation unit<br>
	 * is managed but not its compilation. This should be a bitwise OR of the<br>
	 * CXTranslationUnit_XXX flags.<br>
	 * \param[out] out_TU A non-NULL pointer to store the created<br>
	 * \c CXTranslationUnit, describing the parsed code and containing any<br>
	 * diagnostics produced by the compiler.<br>
	 * \returns Zero on success, otherwise returns an error code.<br>
	 * Original signature : <code>CXErrorCode clang_parseTranslationUnit2(CXIndex, const char*, const const char**, int, CXUnsavedFile*, unsigned, unsigned, CXTranslationUnit*)</code><br>
	 * <i>native declaration : clang-c/Index.h:1280</i>
	 */
	int clang_parseTranslationUnit2(Pointer CIdx, String source_filename, String command_line_args[], int num_command_line_args, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options, PointerByReference out_TU);
	/**
	 * \brief Parse the given source file and the translation unit corresponding<br>
	 * to that file.<br>
	 * This routine is the main entry point for the Clang C API, providing the<br>
	 * ability to parse a source file into a translation unit that can then be<br>
	 * queried by other functions in the API. This routine accepts a set of<br>
	 * command-line arguments so that the compilation can be configured in the same<br>
	 * way that the compiler is configured on the command line.<br>
	 * \param CIdx The index object with which the translation unit will be <br>
	 * associated.<br>
	 * \param source_filename The name of the source file to load, or NULL if the<br>
	 * source file is included in \c command_line_args.<br>
	 * \param command_line_args The command-line arguments that would be<br>
	 * passed to the \c clang executable if it were being invoked out-of-process.<br>
	 * These command-line options will be parsed and will affect how the translation<br>
	 * unit is parsed. Note that the following options are ignored: '-c', <br>
	 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.<br>
	 * \param num_command_line_args The number of command-line arguments in<br>
	 * \c command_line_args.<br>
	 * \param unsaved_files the files that have not yet been saved to disk<br>
	 * but may be required for parsing, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * \param num_unsaved_files the number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * \param options A bitmask of options that affects how the translation unit<br>
	 * is managed but not its compilation. This should be a bitwise OR of the<br>
	 * CXTranslationUnit_XXX flags.<br>
	 * \param[out] out_TU A non-NULL pointer to store the created<br>
	 * \c CXTranslationUnit, describing the parsed code and containing any<br>
	 * diagnostics produced by the compiler.<br>
	 * \returns Zero on success, otherwise returns an error code.<br>
	 * Original signature : <code>CXErrorCode clang_parseTranslationUnit2(CXIndex, const char*, const const char**, int, CXUnsavedFile*, unsigned, unsigned, CXTranslationUnit*)</code><br>
	 * <i>native declaration : clang-c/Index.h:1280</i>
	 */
	int clang_parseTranslationUnit2(Pointer CIdx, Pointer source_filename, PointerByReference command_line_args, int num_command_line_args, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options, PointerByReference out_TU);
	/**
	 * \brief Returns the set of flags that is suitable for saving a translation<br>
	 * unit.<br>
	 * The set of flags returned provide options for<br>
	 * \c clang_saveTranslationUnit() by default. The returned flag<br>
	 * set contains an unspecified set of options that save translation units with<br>
	 * the most commonly-requested data.<br>
	 * Original signature : <code>int clang_defaultSaveOptions(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:1313</i>
	 */
	int clang_defaultSaveOptions(ClangLibrary.CXTranslationUnit TU);
	/**
	 * \brief Saves a translation unit into a serialized representation of<br>
	 * that translation unit on disk.<br>
	 * Any translation unit that was parsed without error can be saved<br>
	 * into a file. The translation unit can then be deserialized into a<br>
	 * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,<br>
	 * if it is an incomplete translation unit that corresponds to a<br>
	 * header, used as a precompiled header when parsing other translation<br>
	 * units.<br>
	 * \param TU The translation unit to save.<br>
	 * \param FileName The file to which the translation unit will be saved.<br>
	 * \param options A bitmask of options that affects how the translation unit<br>
	 * is saved. This should be a bitwise OR of the<br>
	 * CXSaveTranslationUnit_XXX flags.<br>
	 * \returns A value that will match one of the enumerators of the CXSaveError<br>
	 * enumeration. Zero (CXSaveError_None) indicates that the translation unit was <br>
	 * saved successfully, while a non-zero value indicates that a problem occurred.<br>
	 * Original signature : <code>int clang_saveTranslationUnit(CXTranslationUnit, const char*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:1373</i>
	 */
	int clang_saveTranslationUnit(ClangLibrary.CXTranslationUnit TU, String FileName, int options);
	/**
	 * \brief Destroy the specified CXTranslationUnit object.<br>
	 * Original signature : <code>void clang_disposeTranslationUnit(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:1380</i>
	 */
	void clang_disposeTranslationUnit(ClangLibrary.CXTranslationUnit CXTranslationUnit1);
	/**
	 * \brief Returns the set of flags that is suitable for reparsing a translation<br>
	 * unit.<br>
	 * The set of flags returned provide options for<br>
	 * \c clang_reparseTranslationUnit() by default. The returned flag<br>
	 * set contains an unspecified set of optimizations geared toward common uses<br>
	 * of reparsing. The set of optimizations enabled may change from one version <br>
	 * to the next.<br>
	 * Original signature : <code>int clang_defaultReparseOptions(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:1406</i>
	 */
	int clang_defaultReparseOptions(ClangLibrary.CXTranslationUnit TU);
	/**
	 * \brief Reparse the source files that produced this translation unit.<br>
	 * This routine can be used to re-parse the source files that originally<br>
	 * created the given translation unit, for example because those source files<br>
	 * have changed (either on disk or as passed via \p unsaved_files). The<br>
	 * source code will be reparsed with the same command-line options as it<br>
	 * was originally parsed. <br>
	 * Reparsing a translation unit invalidates all cursors and source locations<br>
	 * that refer into that translation unit. This makes reparsing a translation<br>
	 * unit semantically equivalent to destroying the translation unit and then<br>
	 * creating a new translation unit with the same command-line arguments.<br>
	 * However, it may be more efficient to reparse a translation <br>
	 * unit using this routine.<br>
	 * \param TU The translation unit whose contents will be re-parsed. The<br>
	 * translation unit must originally have been built with <br>
	 * \c clang_createTranslationUnitFromSourceFile().<br>
	 * \param num_unsaved_files The number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * \param unsaved_files The files that have not yet been saved to disk<br>
	 * but may be required for parsing, including the contents of<br>
	 * those files.  The contents and name of these files (as specified by<br>
	 * CXUnsavedFile) are copied when necessary, so the client only needs to<br>
	 * guarantee their validity until the call to this function returns.<br>
	 * <br>
	 * \param options A bitset of options composed of the flags in CXReparse_Flags.<br>
	 * The function \c clang_defaultReparseOptions() produces a default set of<br>
	 * options recommended for most uses, based on the translation unit.<br>
	 * \returns 0 if the sources could be reparsed.  A non-zero error code will be<br>
	 * returned if reparsing was impossible, such that the translation unit is<br>
	 * invalid. In such cases, the only valid call for \c TU is<br>
	 * \c clang_disposeTranslationUnit(TU).  The error codes returned by this<br>
	 * routine are described by the \c CXErrorCode enum.<br>
	 * Original signature : <code>int clang_reparseTranslationUnit(CXTranslationUnit, unsigned, CXUnsavedFile*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:1447</i>
	 */
	int clang_reparseTranslationUnit(ClangLibrary.CXTranslationUnit TU, int num_unsaved_files, ClangLibrary.CXUnsavedFile unsaved_files, int options);
	/**
	 * \brief Returns the human-readable null-terminated C string that represents<br>
	 *  the name of the memory category.  This string should never be freed.<br>
	 * Original signature : <code>char* clang_getTUResourceUsageName(CXTUResourceUsageKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:1483</i>
	 */
	String clang_getTUResourceUsageName(int kind);
	/**
	 * \brief Return the memory usage of a translation unit.  This object<br>
	 *  should be released with clang_disposeCXTUResourceUsage().<br>
	 * Original signature : <code>CXTUResourceUsage clang_getCXTUResourceUsage(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:1513</i>
	 */
	ClangLibrary.CXTUResourceUsage.ByValue clang_getCXTUResourceUsage(ClangLibrary.CXTranslationUnit TU);
	/**
	 * Original signature : <code>void clang_disposeCXTUResourceUsage(CXTUResourceUsage)</code><br>
	 * <i>native declaration : clang-c/Index.h:1515</i>
	 */
	void clang_disposeCXTUResourceUsage(ClangLibrary.CXTUResourceUsage.ByValue usage);
	/**
	 * \brief Retrieve the NULL cursor, which represents no entity.<br>
	 * Original signature : <code>CXCursor clang_getNullCursor()</code><br>
	 * <i>native declaration : clang-c/Index.h:2298</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getNullCursor();
	/**
	 * \brief Retrieve the cursor that represents the given translation unit.<br>
	 * The translation unit cursor can be used to start traversing the<br>
	 * various declarations within the given translation unit.<br>
	 * Original signature : <code>CXCursor clang_getTranslationUnitCursor(CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:2306</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getTranslationUnitCursor(ClangLibrary.CXTranslationUnit CXTranslationUnit1);
	/**
	 * \brief Determine whether two cursors are equivalent.<br>
	 * Original signature : <code>int clang_equalCursors(CXCursor, CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2311</i>
	 */
	int clang_equalCursors(ClangLibrary.CXCursor.ByValue CXCursor1, ClangLibrary.CXCursor.ByValue CXCursor2);
	/**
	 * \brief Returns non-zero if \p cursor is null.<br>
	 * Original signature : <code>int clang_Cursor_isNull(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2316</i>
	 */
	int clang_Cursor_isNull(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Compute a hash value for the given cursor.<br>
	 * Original signature : <code>int clang_hashCursor(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2321</i>
	 */
	int clang_hashCursor(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the kind of the given cursor.<br>
	 * Original signature : <code>CXCursorKind clang_getCursorKind(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2326</i>
	 */
	int clang_getCursorKind(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Determine whether the given cursor kind represents a declaration.<br>
	 * Original signature : <code>int clang_isDeclaration(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2331</i>
	 */
	int clang_isDeclaration(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents a simple<br>
	 * reference.<br>
	 * Note that other kinds of cursors (such as expressions) can also refer to<br>
	 * other cursors. Use clang_getCursorReferenced() to determine whether a<br>
	 * particular cursor refers to another entity.<br>
	 * Original signature : <code>int clang_isReference(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2341</i>
	 */
	int clang_isReference(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents an expression.<br>
	 * Original signature : <code>int clang_isExpression(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2346</i>
	 */
	int clang_isExpression(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents a statement.<br>
	 * Original signature : <code>int clang_isStatement(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2351</i>
	 */
	int clang_isStatement(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents an attribute.<br>
	 * Original signature : <code>int clang_isAttribute(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2356</i>
	 */
	int clang_isAttribute(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents an invalid<br>
	 * cursor.<br>
	 * Original signature : <code>int clang_isInvalid(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2362</i>
	 */
	int clang_isInvalid(int arg1);
	/**
	 * \brief Determine whether the given cursor kind represents a translation<br>
	 * unit.<br>
	 * Original signature : <code>int clang_isTranslationUnit(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2368</i>
	 */
	int clang_isTranslationUnit(int arg1);
	/**
	 * \brief Determine whether the given cursor represents a preprocessing<br>
	 * element, such as a preprocessor directive or macro instantiation.<br>
	 * Original signature : <code>int clang_isPreprocessing(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2374</i>
	 */
	int clang_isPreprocessing(int arg1);
	/**
	 * \brief Determine whether the given cursor represents a currently<br>
	 *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).<br>
	 * Original signature : <code>int clang_isUnexposed(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2380</i>
	 */
	int clang_isUnexposed(int arg1);
	/**
	 * \brief Determine the linkage of the entity referred to by a given cursor.<br>
	 * Original signature : <code>CXLinkageKind clang_getCursorLinkage(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2406</i>
	 */
	int clang_getCursorLinkage(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Determine the availability of the entity that this cursor refers to,<br>
	 * taking the current target platform into account.<br>
	 * \param cursor The cursor to query.<br>
	 * \returns The availability of the cursor.<br>
	 * Original signature : <code>CXAvailabilityKind clang_getCursorAvailability(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2416</i>
	 */
	int clang_getCursorAvailability(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Determine the availability of the entity that this cursor refers to<br>
	 * on any platforms for which availability information is known.<br>
	 * \param cursor The cursor to query.<br>
	 * \param always_deprecated If non-NULL, will be set to indicate whether the <br>
	 * entity is deprecated on all platforms.<br>
	 * \param deprecated_message If non-NULL, will be set to the message text <br>
	 * provided along with the unconditional deprecation of this entity. The client<br>
	 * is responsible for deallocating this string.<br>
	 * \param always_unavailable If non-NULL, will be set to indicate whether the<br>
	 * entity is unavailable on all platforms.<br>
	 * \param unavailable_message If non-NULL, will be set to the message text<br>
	 * provided along with the unconditional unavailability of this entity. The <br>
	 * client is responsible for deallocating this string.<br>
	 * \param availability If non-NULL, an array of CXPlatformAvailability instances<br>
	 * that will be populated with platform availability information, up to either<br>
	 * the number of platforms for which availability information is available (as<br>
	 * returned by this function) or \c availability_size, whichever is smaller.<br>
	 * \param availability_size The number of elements available in the <br>
	 * \c availability array.<br>
	 * \returns The number of platforms (N) for which availability information is<br>
	 * available (which is unrelated to \c availability_size).<br>
	 * Note that the client is responsible for calling <br>
	 * \c clang_disposeCXPlatformAvailability to free each of the <br>
	 * platform-availability structures returned. There are <br>
	 * \c min(N, availability_size) such structures.<br>
	 * Original signature : <code>int clang_getCursorPlatformAvailability(CXCursor, int*, CXString*, int*, CXString*, CXPlatformAvailability*, int)</code><br>
	 * <i>native declaration : clang-c/Index.h:2492</i>
	 */
	int clang_getCursorPlatformAvailability(ClangLibrary.CXCursor.ByValue cursor, IntBuffer always_deprecated, ClangLibrary.CXString deprecated_message, IntBuffer always_unavailable, ClangLibrary.CXString unavailable_message, ClangLibrary.CXPlatformAvailability availability, int availability_size);
	/**
	 * \brief Free the memory associated with a \c CXPlatformAvailability structure.<br>
	 * Original signature : <code>void clang_disposeCXPlatformAvailability(CXPlatformAvailability*)</code><br>
	 * <i>native declaration : clang-c/Index.h:2504</i>
	 */
	void clang_disposeCXPlatformAvailability(ClangLibrary.CXPlatformAvailability availability);
	/**
	 * \brief Determine the "language" of the entity referred to by a given cursor.<br>
	 * Original signature : <code>CXLanguageKind clang_getCursorLanguage(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2520</i>
	 */
	int clang_getCursorLanguage(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Returns the translation unit that a cursor originated from.<br>
	 * Original signature : <code>CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2525</i>
	 */
	ClangLibrary.CXTranslationUnit clang_Cursor_getTranslationUnit(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Creates an empty CXCursorSet.<br>
	 * Original signature : <code>CXCursorSet clang_createCXCursorSet()</code><br>
	 * <i>native declaration : clang-c/Index.h:2536</i>
	 */
	ClangLibrary.CXCursorSet clang_createCXCursorSet();
	/**
	 * \brief Disposes a CXCursorSet and releases its associated memory.<br>
	 * Original signature : <code>void clang_disposeCXCursorSet(CXCursorSet)</code><br>
	 * <i>native declaration : clang-c/Index.h:2541</i>
	 */
	void clang_disposeCXCursorSet(ClangLibrary.CXCursorSet cset);
	/**
	 * \brief Queries a CXCursorSet to see if it contains a specific CXCursor.<br>
	 * \returns non-zero if the set contains the specified cursor.<br>
	 * Original signature : <code>int clang_CXCursorSet_contains(CXCursorSet, CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2548</i>
	 */
	int clang_CXCursorSet_contains(ClangLibrary.CXCursorSet cset, ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Inserts a CXCursor into a CXCursorSet.<br>
	 * \returns zero if the CXCursor was already in the set, and non-zero otherwise.<br>
	 * Original signature : <code>int clang_CXCursorSet_insert(CXCursorSet, CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2556</i>
	 */
	int clang_CXCursorSet_insert(ClangLibrary.CXCursorSet cset, ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Determine the semantic parent of the given cursor.<br>
	 * The semantic parent of a cursor is the cursor that semantically contains<br>
	 * the given \p cursor. For many declarations, the lexical and semantic parents<br>
	 * are equivalent (the lexical parent is returned by <br>
	 * \c clang_getCursorLexicalParent()). They diverge when declarations or<br>
	 * definitions are provided out-of-line. For example:<br>
	 * \code<br>
	 * class C {<br>
	 *  void f();<br>
	 * };<br>
	 * void C::f() { }<br>
	 * \endcode<br>
	 * In the out-of-line definition of \c C::f, the semantic parent is<br>
	 * the class \c C, of which this function is a member. The lexical parent is<br>
	 * the place where the declaration actually occurs in the source code; in this<br>
	 * case, the definition occurs in the translation unit. In general, the<br>
	 * lexical parent for a given entity can change without affecting the semantics<br>
	 * of the program, and the lexical parent of different declarations of the<br>
	 * same entity may be different. Changing the semantic parent of a declaration,<br>
	 * on the other hand, can have a major impact on semantics, and redeclarations<br>
	 * of a particular entity should all have the same semantic context.<br>
	 * In the example above, both declarations of \c C::f have \c C as their<br>
	 * semantic context, while the lexical context of the first \c C::f is \c C<br>
	 * and the lexical context of the second \c C::f is the translation unit.<br>
	 * For global declarations, the semantic parent is the translation unit.<br>
	 * Original signature : <code>CXCursor clang_getCursorSemanticParent(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2592</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getCursorSemanticParent(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Determine the lexical parent of the given cursor.<br>
	 * The lexical parent of a cursor is the cursor in which the given \p cursor<br>
	 * was actually written. For many declarations, the lexical and semantic parents<br>
	 * are equivalent (the semantic parent is returned by <br>
	 * \c clang_getCursorSemanticParent()). They diverge when declarations or<br>
	 * definitions are provided out-of-line. For example:<br>
	 * \code<br>
	 * class C {<br>
	 *  void f();<br>
	 * };<br>
	 * void C::f() { }<br>
	 * \endcode<br>
	 * In the out-of-line definition of \c C::f, the semantic parent is<br>
	 * the class \c C, of which this function is a member. The lexical parent is<br>
	 * the place where the declaration actually occurs in the source code; in this<br>
	 * case, the definition occurs in the translation unit. In general, the<br>
	 * lexical parent for a given entity can change without affecting the semantics<br>
	 * of the program, and the lexical parent of different declarations of the<br>
	 * same entity may be different. Changing the semantic parent of a declaration,<br>
	 * on the other hand, can have a major impact on semantics, and redeclarations<br>
	 * of a particular entity should all have the same semantic context.<br>
	 * In the example above, both declarations of \c C::f have \c C as their<br>
	 * semantic context, while the lexical context of the first \c C::f is \c C<br>
	 * and the lexical context of the second \c C::f is the translation unit.<br>
	 * For declarations written in the global scope, the lexical parent is<br>
	 * the translation unit.<br>
	 * Original signature : <code>CXCursor clang_getCursorLexicalParent(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2628</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getCursorLexicalParent(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Determine the set of methods that are overridden by the given<br>
	 * method.<br>
	 * In both Objective-C and C++, a method (aka virtual member function,<br>
	 * in C++) can override a virtual method in a base class. For<br>
	 * Objective-C, a method is said to override any method in the class's<br>
	 * base class, its protocols, or its categories' protocols, that has the same<br>
	 * selector and is of the same kind (class or instance).<br>
	 * If no such method exists, the search continues to the class's superclass,<br>
	 * its protocols, and its categories, and so on. A method from an Objective-C<br>
	 * implementation is considered to override the same methods as its<br>
	 * corresponding method in the interface.<br>
	 * For C++, a virtual member function overrides any virtual member<br>
	 * function with the same signature that occurs in its base<br>
	 * classes. With multiple inheritance, a virtual member function can<br>
	 * override several virtual member functions coming from different<br>
	 * base classes.<br>
	 * In all cases, this function determines the immediate overridden<br>
	 * method, rather than all of the overridden methods. For example, if<br>
	 * a method is originally declared in a class A, then overridden in B<br>
	 * (which in inherits from A) and also in C (which inherited from B),<br>
	 * then the only overridden method returned from this function when<br>
	 * invoked on C's method will be B's method. The client may then<br>
	 * invoke this function again, given the previously-found overridden<br>
	 * methods, to map out the complete method-override set.<br>
	 * \param cursor A cursor representing an Objective-C or C++<br>
	 * method. This routine will compute the set of methods that this<br>
	 * method overrides.<br>
	 * <br>
	 * \param overridden A pointer whose pointee will be replaced with a<br>
	 * pointer to an array of cursors, representing the set of overridden<br>
	 * methods. If there are no overridden methods, the pointee will be<br>
	 * set to NULL. The pointee must be freed via a call to <br>
	 * \c clang_disposeOverriddenCursors().<br>
	 * \param num_overridden A pointer to the number of overridden<br>
	 * functions, will be set to the number of overridden functions in the<br>
	 * array pointed to by \p overridden.<br>
	 * Original signature : <code>void clang_getOverriddenCursors(CXCursor, CXCursor**, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:2673</i>
	 */
	void clang_getOverriddenCursors(ClangLibrary.CXCursor.ByValue cursor, ClangLibrary.CXCursor.ByReference overridden[], IntBuffer num_overridden);
	/**
	 * \brief Determine the set of methods that are overridden by the given<br>
	 * method.<br>
	 * In both Objective-C and C++, a method (aka virtual member function,<br>
	 * in C++) can override a virtual method in a base class. For<br>
	 * Objective-C, a method is said to override any method in the class's<br>
	 * base class, its protocols, or its categories' protocols, that has the same<br>
	 * selector and is of the same kind (class or instance).<br>
	 * If no such method exists, the search continues to the class's superclass,<br>
	 * its protocols, and its categories, and so on. A method from an Objective-C<br>
	 * implementation is considered to override the same methods as its<br>
	 * corresponding method in the interface.<br>
	 * For C++, a virtual member function overrides any virtual member<br>
	 * function with the same signature that occurs in its base<br>
	 * classes. With multiple inheritance, a virtual member function can<br>
	 * override several virtual member functions coming from different<br>
	 * base classes.<br>
	 * In all cases, this function determines the immediate overridden<br>
	 * method, rather than all of the overridden methods. For example, if<br>
	 * a method is originally declared in a class A, then overridden in B<br>
	 * (which in inherits from A) and also in C (which inherited from B),<br>
	 * then the only overridden method returned from this function when<br>
	 * invoked on C's method will be B's method. The client may then<br>
	 * invoke this function again, given the previously-found overridden<br>
	 * methods, to map out the complete method-override set.<br>
	 * \param cursor A cursor representing an Objective-C or C++<br>
	 * method. This routine will compute the set of methods that this<br>
	 * method overrides.<br>
	 * <br>
	 * \param overridden A pointer whose pointee will be replaced with a<br>
	 * pointer to an array of cursors, representing the set of overridden<br>
	 * methods. If there are no overridden methods, the pointee will be<br>
	 * set to NULL. The pointee must be freed via a call to <br>
	 * \c clang_disposeOverriddenCursors().<br>
	 * \param num_overridden A pointer to the number of overridden<br>
	 * functions, will be set to the number of overridden functions in the<br>
	 * array pointed to by \p overridden.<br>
	 * Original signature : <code>void clang_getOverriddenCursors(CXCursor, CXCursor**, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:2673</i>
	 */
	void clang_getOverriddenCursors(ClangLibrary.CXCursor.ByValue cursor, ClangLibrary.CXCursor.ByReference overridden[], IntByReference num_overridden);
	/**
	 * \brief Free the set of overridden cursors returned by \c<br>
	 * clang_getOverriddenCursors().<br>
	 * Original signature : <code>void clang_disposeOverriddenCursors(CXCursor*)</code><br>
	 * <i>native declaration : clang-c/Index.h:2681</i>
	 */
	void clang_disposeOverriddenCursors(ClangLibrary.CXCursor overridden);
	/**
	 * \brief Retrieve the file that is included by the given inclusion directive<br>
	 * cursor.<br>
	 * Original signature : <code>CXFile clang_getIncludedFile(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2687</i>
	 */
	Pointer clang_getIncludedFile(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Map a source location to the cursor that describes the entity at that<br>
	 * location in the source code.<br>
	 * clang_getCursor() maps an arbitrary source location within a translation<br>
	 * unit down to the most specific cursor that describes the entity at that<br>
	 * location. For example, given an expression \c x + y, invoking<br>
	 * clang_getCursor() with a source location pointing to "x" will return the<br>
	 * cursor for "x"; similarly for "y". If the cursor points anywhere between<br>
	 * "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()<br>
	 * will return a cursor referring to the "+" expression.<br>
	 * \returns a cursor representing the entity at the given source location, or<br>
	 * a NULL cursor if no such entity can be found.<br>
	 * Original signature : <code>CXCursor clang_getCursor(CXTranslationUnit, CXSourceLocation)</code><br>
	 * <i>native declaration : clang-c/Index.h:2719</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getCursor(ClangLibrary.CXTranslationUnit CXTranslationUnit1, ClangLibrary.CXSourceLocation.ByValue CXSourceLocation1);
	/**
	 * \brief Retrieve the physical location of the source constructor referenced<br>
	 * by the given cursor.<br>
	 * The location of a declaration is typically the location of the name of that<br>
	 * declaration, where the name of that declaration would occur if it is<br>
	 * unnamed, or some keyword that introduces that particular declaration.<br>
	 * The location of a reference is where that reference occurs within the<br>
	 * source code.<br>
	 * Original signature : <code>CXSourceLocation clang_getCursorLocation(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2731</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getCursorLocation(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the physical extent of the source construct referenced by<br>
	 * the given cursor.<br>
	 * The extent of a cursor starts with the file/line/column pointing at the<br>
	 * first character within the source construct that the cursor refers to and<br>
	 * ends with the last character within that source construct. For a<br>
	 * declaration, the extent covers the declaration itself. For a reference,<br>
	 * the extent covers the location of the reference (e.g., where the referenced<br>
	 * entity was actually used).<br>
	 * Original signature : <code>CXSourceRange clang_getCursorExtent(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2744</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_getCursorExtent(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the type of a CXCursor (if any).<br>
	 * Original signature : <code>CXType clang_getCursorType(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2857</i>
	 */
	ClangLibrary.CXType.ByValue clang_getCursorType(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Pretty-print the underlying type using the rules of the<br>
	 * language of the translation unit from which it came.<br>
	 * If the type is invalid, an empty string is returned.<br>
	 * Original signature : <code>CXString clang_getTypeSpelling(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2865</i>
	 */
	ClangLibrary.CXString.ByValue clang_getTypeSpelling(ClangLibrary.CXType.ByValue CT);
	/**
	 * \brief Retrieve the underlying type of a typedef declaration.<br>
	 * If the cursor does not reference a typedef declaration, an invalid type is<br>
	 * returned.<br>
	 * Original signature : <code>CXType clang_getTypedefDeclUnderlyingType(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2873</i>
	 */
	ClangLibrary.CXType.ByValue clang_getTypedefDeclUnderlyingType(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the integer type of an enum declaration.<br>
	 * If the cursor does not reference an enum declaration, an invalid type is<br>
	 * returned.<br>
	 * Original signature : <code>CXType clang_getEnumDeclIntegerType(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2881</i>
	 */
	ClangLibrary.CXType.ByValue clang_getEnumDeclIntegerType(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the integer value of an enum constant declaration as a signed<br>
	 *  long long.<br>
	 * If the cursor does not reference an enum constant declaration, LLONG_MIN is returned.<br>
	 * Since this is also potentially a valid constant value, the kind of the cursor<br>
	 * must be verified before calling this function.<br>
	 * Original signature : <code>long long clang_getEnumConstantDeclValue(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2891</i>
	 */
	long clang_getEnumConstantDeclValue(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the integer value of an enum constant declaration as an unsigned<br>
	 *  long long.<br>
	 * If the cursor does not reference an enum constant declaration, ULLONG_MAX is returned.<br>
	 * Since this is also potentially a valid constant value, the kind of the cursor<br>
	 * must be verified before calling this function.<br>
	 * Original signature : <code>long long clang_getEnumConstantDeclUnsignedValue(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2901</i>
	 */
	long clang_getEnumConstantDeclUnsignedValue(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the bit width of a bit field declaration as an integer.<br>
	 * If a cursor that is not a bit field declaration is passed in, -1 is returned.<br>
	 * Original signature : <code>int clang_getFieldDeclBitWidth(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2908</i>
	 */
	int clang_getFieldDeclBitWidth(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the number of non-variadic arguments associated with a given<br>
	 * cursor.<br>
	 * The number of arguments can be determined for calls as well as for<br>
	 * declarations of functions or methods. For other cursors -1 is returned.<br>
	 * Original signature : <code>int clang_Cursor_getNumArguments(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2917</i>
	 */
	int clang_Cursor_getNumArguments(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the argument cursor of a function or method.<br>
	 * The argument cursor can be determined for calls as well as for declarations<br>
	 * of functions or methods. For other cursors and for invalid indices, an<br>
	 * invalid cursor is returned.<br>
	 * Original signature : <code>CXCursor clang_Cursor_getArgument(CXCursor, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:2926</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_Cursor_getArgument(ClangLibrary.CXCursor.ByValue C, int i);
	/**
	 * \brief Determine whether two CXTypes represent the same type.<br>
	 * \returns non-zero if the CXTypes represent the same type and<br>
	 *          zero otherwise.<br>
	 * Original signature : <code>int clang_equalTypes(CXType, CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2934</i>
	 */
	int clang_equalTypes(ClangLibrary.CXType.ByValue A, ClangLibrary.CXType.ByValue B);
	/**
	 * \brief Return the canonical type for a CXType.<br>
	 * Clang's type system explicitly models typedefs and all the ways<br>
	 * a specific type can be represented.  The canonical type is the underlying<br>
	 * type with all the "sugar" removed.  For example, if 'T' is a typedef<br>
	 * for 'int', the canonical type for 'T' would be 'int'.<br>
	 * Original signature : <code>CXType clang_getCanonicalType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2944</i>
	 */
	ClangLibrary.CXType.ByValue clang_getCanonicalType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Determine whether a CXType has the "const" qualifier set,<br>
	 * without looking through typedefs that may have added "const" at a<br>
	 * different level.<br>
	 * Original signature : <code>int clang_isConstQualifiedType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2951</i>
	 */
	int clang_isConstQualifiedType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Determine whether a CXType has the "volatile" qualifier set,<br>
	 * without looking through typedefs that may have added "volatile" at<br>
	 * a different level.<br>
	 * Original signature : <code>int clang_isVolatileQualifiedType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2958</i>
	 */
	int clang_isVolatileQualifiedType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Determine whether a CXType has the "restrict" qualifier set,<br>
	 * without looking through typedefs that may have added "restrict" at a<br>
	 * different level.<br>
	 * Original signature : <code>int clang_isRestrictQualifiedType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2965</i>
	 */
	int clang_isRestrictQualifiedType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief For pointer types, returns the type of the pointee.<br>
	 * Original signature : <code>CXType clang_getPointeeType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2970</i>
	 */
	ClangLibrary.CXType.ByValue clang_getPointeeType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the cursor for the declaration of the given type.<br>
	 * Original signature : <code>CXCursor clang_getTypeDeclaration(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2975</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getTypeDeclaration(ClangLibrary.CXType.ByValue T);
	/**
	 * Returns the Objective-C type encoding for the specified declaration.<br>
	 * Original signature : <code>CXString clang_getDeclObjCTypeEncoding(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:2980</i>
	 */
	ClangLibrary.CXString.ByValue clang_getDeclObjCTypeEncoding(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the spelling of a given CXTypeKind.<br>
	 * Original signature : <code>CXString clang_getTypeKindSpelling(CXTypeKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:2985</i>
	 */
	ClangLibrary.CXString.ByValue clang_getTypeKindSpelling(int K);
	/**
	 * \brief Retrieve the calling convention associated with a function type.<br>
	 * If a non-function type is passed in, CXCallingConv_Invalid is returned.<br>
	 * Original signature : <code>CXCallingConv clang_getFunctionTypeCallingConv(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2992</i>
	 */
	int clang_getFunctionTypeCallingConv(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Retrieve the return type associated with a function type.<br>
	 * If a non-function type is passed in, an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getResultType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:2999</i>
	 */
	ClangLibrary.CXType.ByValue clang_getResultType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Retrieve the number of non-variadic parameters associated with a<br>
	 * function type.<br>
	 * If a non-function type is passed in, -1 is returned.<br>
	 * Original signature : <code>int clang_getNumArgTypes(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3007</i>
	 */
	int clang_getNumArgTypes(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Retrieve the type of a parameter of a function type.<br>
	 * If a non-function type is passed in or the function does not have enough<br>
	 * parameters, an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getArgType(CXType, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:3015</i>
	 */
	ClangLibrary.CXType.ByValue clang_getArgType(ClangLibrary.CXType.ByValue T, int i);
	/**
	 * \brief Return 1 if the CXType is a variadic function type, and 0 otherwise.<br>
	 * Original signature : <code>int clang_isFunctionTypeVariadic(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3020</i>
	 */
	int clang_isFunctionTypeVariadic(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Retrieve the return type associated with a given cursor.<br>
	 * This only returns a valid type if the cursor refers to a function or method.<br>
	 * Original signature : <code>CXType clang_getCursorResultType(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3027</i>
	 */
	ClangLibrary.CXType.ByValue clang_getCursorResultType(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Return 1 if the CXType is a POD (plain old data) type, and 0<br>
	 *  otherwise.<br>
	 * Original signature : <code>int clang_isPODType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3033</i>
	 */
	int clang_isPODType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the element type of an array, complex, or vector type.<br>
	 * If a type is passed in that is not an array, complex, or vector type,<br>
	 * an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getElementType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3041</i>
	 */
	ClangLibrary.CXType.ByValue clang_getElementType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the number of elements of an array or vector type.<br>
	 * If a type is passed in that is not an array or vector type,<br>
	 * -1 is returned.<br>
	 * Original signature : <code>long long clang_getNumElements(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3049</i>
	 */
	long clang_getNumElements(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the element type of an array type.<br>
	 * If a non-array type is passed in, an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_getArrayElementType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3056</i>
	 */
	ClangLibrary.CXType.ByValue clang_getArrayElementType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the array size of a constant array.<br>
	 * If a non-array type is passed in, -1 is returned.<br>
	 * Original signature : <code>long long clang_getArraySize(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3063</i>
	 */
	long clang_getArraySize(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the alignment of a type in bytes as per C++[expr.alignof]<br>
	 *   standard.<br>
	 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.<br>
	 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete<br>
	 *   is returned.<br>
	 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is<br>
	 *   returned.<br>
	 * If the type declaration is not a constant size type,<br>
	 *   CXTypeLayoutError_NotConstantSize is returned.<br>
	 * Original signature : <code>long long clang_Type_getAlignOf(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3108</i>
	 */
	long clang_Type_getAlignOf(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the class type of an member pointer type.<br>
	 * If a non-member-pointer type is passed in, an invalid type is returned.<br>
	 * Original signature : <code>CXType clang_Type_getClassType(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3115</i>
	 */
	ClangLibrary.CXType.ByValue clang_Type_getClassType(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the size of a type in bytes as per C++[expr.sizeof] standard.<br>
	 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.<br>
	 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete<br>
	 *   is returned.<br>
	 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is<br>
	 *   returned.<br>
	 * Original signature : <code>long long clang_Type_getSizeOf(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3126</i>
	 */
	long clang_Type_getSizeOf(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Return the offset of a field named S in a record of type T in bits<br>
	 *   as it would be returned by __offsetof__ as per C++11[18.2p4]<br>
	 * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid<br>
	 *   is returned.<br>
	 * If the field's type declaration is an incomplete type,<br>
	 *   CXTypeLayoutError_Incomplete is returned.<br>
	 * If the field's type declaration is a dependent type,<br>
	 *   CXTypeLayoutError_Dependent is returned.<br>
	 * If the field's name S is not found,<br>
	 *   CXTypeLayoutError_InvalidFieldName is returned.<br>
	 * Original signature : <code>long long clang_Type_getOffsetOf(CXType, const char*)</code><br>
	 * <i>native declaration : clang-c/Index.h:3141</i>
	 */
	long clang_Type_getOffsetOf(ClangLibrary.CXType.ByValue T, String S);
	/**
	 * \brief Returns the number of template arguments for given class template<br>
	 * specialization, or -1 if type \c T is not a class template specialization.<br>
	 * Variadic argument packs count as only one argument, and can not be inspected<br>
	 * further.<br>
	 * Original signature : <code>int clang_Type_getNumTemplateArguments(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3159</i>
	 */
	int clang_Type_getNumTemplateArguments(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Returns the type template argument of a template class specialization<br>
	 * at given index.<br>
	 * This function only returns template type arguments and does not handle<br>
	 * template template arguments or variadic packs.<br>
	 * Original signature : <code>CXType clang_Type_getTemplateArgumentAsType(CXType, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:3168</i>
	 */
	ClangLibrary.CXType.ByValue clang_Type_getTemplateArgumentAsType(ClangLibrary.CXType.ByValue T, int i);
	/**
	 * \brief Retrieve the ref-qualifier kind of a function or method.<br>
	 * The ref-qualifier is returned for C++ functions or methods. For other types<br>
	 * or non-C++ declarations, CXRefQualifier_None is returned.<br>
	 * Original signature : <code>CXRefQualifierKind clang_Type_getCXXRefQualifier(CXType)</code><br>
	 * <i>native declaration : clang-c/Index.h:3176</i>
	 */
	int clang_Type_getCXXRefQualifier(ClangLibrary.CXType.ByValue T);
	/**
	 * \brief Returns non-zero if the cursor specifies a Record member that is a<br>
	 *   bitfield.<br>
	 * Original signature : <code>int clang_Cursor_isBitField(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3182</i>
	 */
	int clang_Cursor_isBitField(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Returns 1 if the base class specified by the cursor with kind<br>
	 *   CX_CXXBaseSpecifier is virtual.<br>
	 * Original signature : <code>int clang_isVirtualBase(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3188</i>
	 */
	int clang_isVirtualBase(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Returns the access control level for the referenced object.<br>
	 * If the cursor refers to a C++ declaration, its access control level within its<br>
	 * parent scope is returned. Otherwise, if the cursor refers to a base specifier or<br>
	 * access specifier, the specifier itself is returned.<br>
	 * Original signature : <code>CX_CXXAccessSpecifier clang_getCXXAccessSpecifier(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3208</i>
	 */
	int clang_getCXXAccessSpecifier(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Determine the number of overloaded declarations referenced by a <br>
	 * \c CXCursor_OverloadedDeclRef cursor.<br>
	 * \param cursor The cursor whose overloaded declarations are being queried.<br>
	 * \returns The number of overloaded declarations referenced by \c cursor. If it<br>
	 * is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.<br>
	 * Original signature : <code>int clang_getNumOverloadedDecls(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3219</i>
	 */
	int clang_getNumOverloadedDecls(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Retrieve a cursor for one of the overloaded declarations referenced<br>
	 * by a \c CXCursor_OverloadedDeclRef cursor.<br>
	 * \param cursor The cursor whose overloaded declarations are being queried.<br>
	 * \param index The zero-based index into the set of overloaded declarations in<br>
	 * the cursor.<br>
	 * \returns A cursor representing the declaration referenced by the given <br>
	 * \c cursor at the specified \c index. If the cursor does not have an <br>
	 * associated set of overloaded declarations, or if the index is out of bounds,<br>
	 * returns \c clang_getNullCursor();<br>
	 * Original signature : <code>CXCursor clang_getOverloadedDecl(CXCursor, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:3235</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getOverloadedDecl(ClangLibrary.CXCursor.ByValue cursor, int index);
	/**
	 * \brief For cursors representing an iboutletcollection attribute,<br>
	 *  this function returns the collection element type.<br>
	 * Original signature : <code>CXType clang_getIBOutletCollectionType(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3254</i>
	 */
	ClangLibrary.CXType.ByValue clang_getIBOutletCollectionType(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Visit the children of a particular cursor.<br>
	 * This function visits all the direct children of the given cursor,<br>
	 * invoking the given \p visitor function with the cursors of each<br>
	 * visited child. The traversal may be recursive, if the visitor returns<br>
	 * \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if<br>
	 * the visitor returns \c CXChildVisit_Break.<br>
	 * \param parent the cursor whose child may be visited. All kinds of<br>
	 * cursors can be visited, including invalid cursors (which, by<br>
	 * definition, have no children).<br>
	 * \param visitor the visitor function that will be invoked for each<br>
	 * child of \p parent.<br>
	 * \param client_data pointer data supplied by the client, which will<br>
	 * be passed to the visitor each time it is invoked.<br>
	 * \returns a non-zero value if the traversal was terminated<br>
	 * prematurely by the visitor returning \c CXChildVisit_Break.<br>
	 * Original signature : <code>int clang_visitChildren(CXCursor, CXCursorVisitor, CXClientData)</code><br>
	 * <i>native declaration : clang-c/Index.h:3331</i>
	 */
	int clang_visitChildren(ClangLibrary.CXCursor.ByValue parent, ClangLibrary.CXCursorVisitor visitor, Pointer client_data);
	/**
	 * \brief Retrieve a Unified Symbol Resolution (USR) for the entity referenced<br>
	 * by the given cursor.<br>
	 * A Unified Symbol Resolution (USR) is a string that identifies a particular<br>
	 * entity (function, class, variable, etc.) within a program. USRs can be<br>
	 * compared across translation units to determine, e.g., when references in<br>
	 * one translation refer to an entity defined in another translation unit.<br>
	 * Original signature : <code>CXString clang_getCursorUSR(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3382</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCursorUSR(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Construct a USR for a specified Objective-C class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCClass(const char*)</code><br>
	 * <i>native declaration : clang-c/Index.h:3387</i>
	 */
	ClangLibrary.CXString.ByValue clang_constructUSR_ObjCClass(String class_name);
	/**
	 * \brief Construct a USR for a specified Objective-C category.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCCategory(const char*, const char*)</code><br>
	 * <i>native declaration : clang-c/Index.h:3392</i>
	 */
	ClangLibrary.CXString.ByValue clang_constructUSR_ObjCCategory(String class_name, String category_name);
	/**
	 * \brief Construct a USR for a specified Objective-C protocol.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCProtocol(const char*)</code><br>
	 * <i>native declaration : clang-c/Index.h:3399</i>
	 */
	ClangLibrary.CXString.ByValue clang_constructUSR_ObjCProtocol(String protocol_name);
	/**
	 * \brief Construct a USR for a specified Objective-C instance variable and<br>
	 *   the USR for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCIvar(const char*, CXString)</code><br>
	 * <i>native declaration : clang-c/Index.h:3407</i>
	 */
	ClangLibrary.CXString.ByValue clang_constructUSR_ObjCIvar(String name, ClangLibrary.CXString.ByValue classUSR);
	/**
	 * \brief Construct a USR for a specified Objective-C method and<br>
	 *   the USR for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCMethod(const char*, unsigned, CXString)</code><br>
	 * <i>native declaration : clang-c/Index.h:3414</i>
	 */
	ClangLibrary.CXString.ByValue clang_constructUSR_ObjCMethod(String name, int isInstanceMethod, ClangLibrary.CXString.ByValue classUSR);
	/**
	 * \brief Construct a USR for a specified Objective-C property and the USR<br>
	 *  for its containing class.<br>
	 * Original signature : <code>CXString clang_constructUSR_ObjCProperty(__declspec(property) const char*, CXString)</code><br>
	 * <i>native declaration : clang-c/Index.h:3422</i>
	 */
	ClangLibrary.CXString.ByValue clang_constructUSR_ObjCProperty(byte charPtr1[], ClangLibrary.CXString.ByValue classUSR);
	/**
	 * \brief Retrieve a name for the entity referenced by this cursor.<br>
	 * Original signature : <code>CXString clang_getCursorSpelling(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3428</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCursorSpelling(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve a range for a piece that forms the cursors spelling name.<br>
	 * Most of the times there is only one range for the complete spelling but for<br>
	 * Objective-C methods and Objective-C message expressions, there are multiple<br>
	 * pieces for each selector identifier.<br>
	 * <br>
	 * \param pieceIndex the index of the spelling name piece. If this is greater<br>
	 * than the actual number of pieces, it will return a NULL (invalid) range.<br>
	 *  <br>
	 * \param options Reserved.<br>
	 * Original signature : <code>CXSourceRange clang_Cursor_getSpellingNameRange(CXCursor, unsigned, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:3441</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_Cursor_getSpellingNameRange(ClangLibrary.CXCursor.ByValue CXCursor1, int pieceIndex, int options);
	/**
	 * \brief Retrieve the display name for the entity referenced by this cursor.<br>
	 * The display name contains extra information that helps identify the cursor,<br>
	 * such as the parameters of a function or template or the arguments of a <br>
	 * class template specialization.<br>
	 * Original signature : <code>CXString clang_getCursorDisplayName(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3452</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCursorDisplayName(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief For a cursor that is a reference, retrieve a cursor representing the<br>
	 * entity that it references.<br>
	 * Reference cursors refer to other entities in the AST. For example, an<br>
	 * Objective-C superclass reference cursor refers to an Objective-C class.<br>
	 * This function produces the cursor for the Objective-C class from the<br>
	 * cursor for the superclass reference. If the input cursor is a declaration or<br>
	 * definition, it returns that declaration or definition unchanged.<br>
	 * Otherwise, returns the NULL cursor.<br>
	 * Original signature : <code>CXCursor clang_getCursorReferenced(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3464</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getCursorReferenced(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief For a cursor that is either a reference to or a declaration<br>
	 *  of some entity, retrieve a cursor that describes the definition of<br>
	 *  that entity.<br>
	 *  Some entities can be declared multiple times within a translation<br>
	 *  unit, but only one of those declarations can also be a<br>
	 *  definition. For example, given:<br>
	 *  \code<br>
	 *  int f(int, int);<br>
	 *  int g(int x, int y) { return f(x, y); }<br>
	 *  int f(int a, int b) { return a + b; }<br>
	 *  int f(int, int);<br>
	 *  \endcode<br>
	 *  there are three declarations of the function "f", but only the<br>
	 *  second one is a definition. The clang_getCursorDefinition()<br>
	 *  function will take any cursor pointing to a declaration of "f"<br>
	 *  (the first or fourth lines of the example) or a cursor referenced<br>
	 *  that uses "f" (the call to "f' inside "g") and will return a<br>
	 *  declaration cursor pointing to the definition (the second "f"<br>
	 *  declaration).<br>
	 *  If given a cursor for which there is no corresponding definition,<br>
	 *  e.g., because there is no definition of that entity within this<br>
	 *  translation unit, returns a NULL cursor.<br>
	 * Original signature : <code>CXCursor clang_getCursorDefinition(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3494</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getCursorDefinition(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Determine whether the declaration pointed to by this cursor<br>
	 * is also a definition of that entity.<br>
	 * Original signature : <code>int clang_isCursorDefinition(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3500</i>
	 */
	int clang_isCursorDefinition(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Retrieve the canonical cursor corresponding to the given cursor.<br>
	 * In the C family of languages, many kinds of entities can be declared several<br>
	 * times within a single translation unit. For example, a structure type can<br>
	 * be forward-declared (possibly multiple times) and later defined:<br>
	 * \code<br>
	 * struct X;<br>
	 * struct X;<br>
	 * struct X {<br>
	 *   int member;<br>
	 * };<br>
	 * \endcode<br>
	 * The declarations and the definition of \c X are represented by three <br>
	 * different cursors, all of which are declarations of the same underlying <br>
	 * entity. One of these cursor is considered the "canonical" cursor, which<br>
	 * is effectively the representative for the underlying entity. One can <br>
	 * determine if two cursors are declarations of the same underlying entity by<br>
	 * comparing their canonical cursors.<br>
	 * \returns The canonical cursor for the entity referred to by the given cursor.<br>
	 * Original signature : <code>CXCursor clang_getCanonicalCursor(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3526</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getCanonicalCursor(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief If the cursor points to a selector identifier in an Objective-C<br>
	 * method or message expression, this returns the selector index.<br>
	 * After getting a cursor with #clang_getCursor, this can be called to<br>
	 * determine if the location points to a selector identifier.<br>
	 * \returns The selector index if the cursor is an Objective-C method or message<br>
	 * expression and the cursor is pointing to a selector identifier, or -1<br>
	 * otherwise.<br>
	 * Original signature : <code>int clang_Cursor_getObjCSelectorIndex(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3540</i>
	 */
	int clang_Cursor_getObjCSelectorIndex(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Given a cursor pointing to a C++ method call or an Objective-C<br>
	 * message, returns non-zero if the method/message is "dynamic", meaning:<br>
	 * <br>
	 * For a C++ method: the call is virtual.<br>
	 * For an Objective-C message: the receiver is an object instance, not 'super'<br>
	 * or a specific class.<br>
	 * <br>
	 * If the method/message is "static" or the cursor does not point to a<br>
	 * method/message, it will return zero.<br>
	 * Original signature : <code>int clang_Cursor_isDynamicCall(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3553</i>
	 */
	int clang_Cursor_isDynamicCall(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor pointing to an Objective-C message, returns the CXType<br>
	 * of the receiver.<br>
	 * Original signature : <code>CXType clang_Cursor_getReceiverType(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3559</i>
	 */
	ClangLibrary.CXType.ByValue clang_Cursor_getReceiverType(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a property declaration, return the<br>
	 * associated property attributes. The bits are formed from<br>
	 * \c CXObjCPropertyAttrKind.<br>
	 * \param reserved Reserved for future use, pass 0.<br>
	 * Original signature : <code>int clang_Cursor_getObjCPropertyAttributes(CXCursor, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:3587</i>
	 */
	int clang_Cursor_getObjCPropertyAttributes(ClangLibrary.CXCursor.ByValue C, int reserved);
	/**
	 * \brief Given a cursor that represents an Objective-C method or parameter<br>
	 * declaration, return the associated Objective-C qualifiers for the return<br>
	 * type or the parameter respectively. The bits are formed from<br>
	 * CXObjCDeclQualifierKind.<br>
	 * Original signature : <code>int clang_Cursor_getObjCDeclQualifiers(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3610</i>
	 */
	int clang_Cursor_getObjCDeclQualifiers(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents an Objective-C method or property<br>
	 * declaration, return non-zero if the declaration was affected by "@optional".<br>
	 * Returns zero if the cursor is not such a declaration or it is "@required".<br>
	 * Original signature : <code>int clang_Cursor_isObjCOptional(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3617</i>
	 */
	int clang_Cursor_isObjCOptional(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Returns non-zero if the given cursor is a variadic function or method.<br>
	 * Original signature : <code>int clang_Cursor_isVariadic(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3622</i>
	 */
	int clang_Cursor_isVariadic(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a declaration, return the associated<br>
	 * comment's source range.  The range may include multiple consecutive comments<br>
	 * with whitespace in between.<br>
	 * Original signature : <code>CXSourceRange clang_Cursor_getCommentRange(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3629</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_Cursor_getCommentRange(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a declaration, return the associated<br>
	 * comment text, including comment markers.<br>
	 * Original signature : <code>CXString clang_Cursor_getRawCommentText(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3635</i>
	 */
	ClangLibrary.CXString.ByValue clang_Cursor_getRawCommentText(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a documentable entity (e.g.,<br>
	 * declaration), return the associated \\brief paragraph; otherwise return the<br>
	 * first paragraph.<br>
	 * Original signature : <code>CXString clang_Cursor_getBriefCommentText(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3642</i>
	 */
	ClangLibrary.CXString.ByValue clang_Cursor_getBriefCommentText(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Retrieve the CXString representing the mangled name of the cursor.<br>
	 * Original signature : <code>CXString clang_Cursor_getMangling(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3656</i>
	 */
	ClangLibrary.CXString.ByValue clang_Cursor_getMangling(ClangLibrary.CXCursor.ByValue CXCursor1);
	/**
	 * \brief Given a CXCursor_ModuleImportDecl cursor, return the associated module.<br>
	 * Original signature : <code>CXModule clang_Cursor_getModule(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3675</i>
	 */
	Pointer clang_Cursor_getModule(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a CXFile header file, return the module that contains it, if one<br>
	 * exists.<br>
	 * Original signature : <code>CXModule clang_getModuleForFile(CXTranslationUnit, CXFile)</code><br>
	 * <i>native declaration : clang-c/Index.h:3681</i>
	 */
	Pointer clang_getModuleForFile(ClangLibrary.CXTranslationUnit CXTranslationUnit1, Pointer CXFile1);
	/**
	 * \param Module a module object.<br>
	 * \returns the module file where the provided module object came from.<br>
	 * Original signature : <code>CXFile clang_Module_getASTFile(CXModule)</code><br>
	 * <i>native declaration : clang-c/Index.h:3688</i>
	 */
	Pointer clang_Module_getASTFile(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * \returns the parent of a sub-module or NULL if the given module is top-level,<br>
	 * e.g. for 'std.vector' it will return the 'std' module.<br>
	 * Original signature : <code>CXModule clang_Module_getParent(CXModule)</code><br>
	 * <i>native declaration : clang-c/Index.h:3696</i>
	 */
	Pointer clang_Module_getParent(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * \returns the name of the module, e.g. for the 'std.vector' sub-module it<br>
	 * will return "vector".<br>
	 * Original signature : <code>CXString clang_Module_getName(CXModule)</code><br>
	 * <i>native declaration : clang-c/Index.h:3704</i>
	 */
	ClangLibrary.CXString.ByValue clang_Module_getName(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * \returns the full name of the module, e.g. "std.vector".<br>
	 * Original signature : <code>CXString clang_Module_getFullName(CXModule)</code><br>
	 * <i>native declaration : clang-c/Index.h:3711</i>
	 */
	ClangLibrary.CXString.ByValue clang_Module_getFullName(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * \returns non-zero if the module is a system one.<br>
	 * Original signature : <code>int clang_Module_isSystem(CXModule)</code><br>
	 * <i>native declaration : clang-c/Index.h:3718</i>
	 */
	int clang_Module_isSystem(Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * \returns the number of top level headers associated with this module.<br>
	 * Original signature : <code>int clang_Module_getNumTopLevelHeaders(CXTranslationUnit, CXModule)</code><br>
	 * <i>native declaration : clang-c/Index.h:3725</i>
	 */
	int clang_Module_getNumTopLevelHeaders(ClangLibrary.CXTranslationUnit CXTranslationUnit1, Pointer Module);
	/**
	 * \param Module a module object.<br>
	 * \param Index top level header index (zero-based).<br>
	 * \returns the specified top level header associated with the module.<br>
	 * Original signature : <code>CXFile clang_Module_getTopLevelHeader(CXTranslationUnit, CXModule, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:3736</i>
	 */
	Pointer clang_Module_getTopLevelHeader(ClangLibrary.CXTranslationUnit CXTranslationUnit1, Pointer Module, int Index);
	/**
	 * \brief Determine if a C++ member function or member function template is<br>
	 * pure virtual.<br>
	 * Original signature : <code>int clang_CXXMethod_isPureVirtual(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3756</i>
	 */
	int clang_CXXMethod_isPureVirtual(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Determine if a C++ member function or member function template is <br>
	 * declared 'static'.<br>
	 * Original signature : <code>int clang_CXXMethod_isStatic(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3762</i>
	 */
	int clang_CXXMethod_isStatic(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Determine if a C++ member function or member function template is<br>
	 * explicitly declared 'virtual' or if it overrides a virtual method from<br>
	 * one of the base classes.<br>
	 * Original signature : <code>int clang_CXXMethod_isVirtual(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3769</i>
	 */
	int clang_CXXMethod_isVirtual(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Determine if a C++ member function or member function template is<br>
	 * declared 'const'.<br>
	 * Original signature : <code>int clang_CXXMethod_isConst(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3775</i>
	 */
	int clang_CXXMethod_isConst(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that represents a template, determine<br>
	 * the cursor kind of the specializations would be generated by instantiating<br>
	 * the template.<br>
	 * This routine can be used to determine what flavor of function template,<br>
	 * class template, or class template partial specialization is stored in the<br>
	 * cursor. For example, it can describe whether a class template cursor is<br>
	 * declared with "struct", "class" or "union".<br>
	 * \param C The cursor to query. This cursor should represent a template<br>
	 * declaration.<br>
	 * \returns The cursor kind of the specializations that would be generated<br>
	 * by instantiating the template \p C. If \p C is not a template, returns<br>
	 * \c CXCursor_NoDeclFound.<br>
	 * Original signature : <code>CXCursorKind clang_getTemplateCursorKind(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3794</i>
	 */
	int clang_getTemplateCursorKind(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that may represent a specialization or instantiation<br>
	 * of a template, retrieve the cursor that represents the template that it<br>
	 * specializes or from which it was instantiated.<br>
	 * This routine determines the template involved both for explicit <br>
	 * specializations of templates and for implicit instantiations of the template,<br>
	 * both of which are referred to as "specializations". For a class template<br>
	 * specialization (e.g., \c std::vector<bool>), this routine will return <br>
	 * either the primary template (\c std::vector) or, if the specialization was<br>
	 * instantiated from a class template partial specialization, the class template<br>
	 * partial specialization. For a class template partial specialization and a<br>
	 * function template specialization (including instantiations), this<br>
	 * this routine will return the specialized template.<br>
	 * For members of a class template (e.g., member functions, member classes, or<br>
	 * static data members), returns the specialized or instantiated member. <br>
	 * Although not strictly "templates" in the C++ language, members of class<br>
	 * templates have the same notions of specializations and instantiations that<br>
	 * templates do, so this routine treats them similarly.<br>
	 * \param C A cursor that may be a specialization of a template or a member<br>
	 * of a template.<br>
	 * \returns If the given cursor is a specialization or instantiation of a <br>
	 * template or a member thereof, the template or member that it specializes or<br>
	 * from which it was instantiated. Otherwise, returns a NULL cursor.<br>
	 * Original signature : <code>CXCursor clang_getSpecializedCursorTemplate(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:3824</i>
	 */
	ClangLibrary.CXCursor.ByValue clang_getSpecializedCursorTemplate(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \brief Given a cursor that references something else, return the source range<br>
	 * covering that reference.<br>
	 * \param C A cursor pointing to a member reference, a declaration reference, or<br>
	 * an operator call.<br>
	 * \param NameFlags A bitset with three independent flags: <br>
	 * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and<br>
	 * CXNameRange_WantSinglePiece.<br>
	 * \param PieceIndex For contiguous names or when passing the flag <br>
	 * CXNameRange_WantSinglePiece, only one piece with index 0 is <br>
	 * available. When the CXNameRange_WantSinglePiece flag is not passed for a<br>
	 * non-contiguous names, this index can be used to retrieve the individual<br>
	 * pieces of the name. See also CXNameRange_WantSinglePiece.<br>
	 * \returns The piece of the name pointed to by the given cursor. If there is no<br>
	 * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.<br>
	 * Original signature : <code>CXSourceRange clang_getCursorReferenceNameRange(CXCursor, unsigned, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:3844</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_getCursorReferenceNameRange(ClangLibrary.CXCursor.ByValue C, int NameFlags, int PieceIndex);
	/**
	 * \brief Determine the kind of the given token.<br>
	 * Original signature : <code>CXTokenKind clang_getTokenKind(CXToken)</code><br>
	 * <i>native declaration : clang-c/Index.h:3929</i>
	 */
	int clang_getTokenKind(ClangLibrary.CXToken.ByValue CXToken1);
	/**
	 * \brief Determine the spelling of the given token.<br>
	 * The spelling of a token is the textual representation of that token, e.g.,<br>
	 * the text of an identifier or keyword.<br>
	 * Original signature : <code>CXString clang_getTokenSpelling(CXTranslationUnit, CXToken)</code><br>
	 * <i>native declaration : clang-c/Index.h:3937</i>
	 */
	ClangLibrary.CXString.ByValue clang_getTokenSpelling(ClangLibrary.CXTranslationUnit CXTranslationUnit1, ClangLibrary.CXToken.ByValue CXToken1);
	/**
	 * \brief Retrieve the source location of the given token.<br>
	 * Original signature : <code>CXSourceLocation clang_getTokenLocation(CXTranslationUnit, CXToken)</code><br>
	 * <i>native declaration : clang-c/Index.h:3942</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_getTokenLocation(ClangLibrary.CXTranslationUnit CXTranslationUnit1, ClangLibrary.CXToken.ByValue CXToken1);
	/**
	 * \brief Retrieve a source range that covers the given token.<br>
	 * Original signature : <code>CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken)</code><br>
	 * <i>native declaration : clang-c/Index.h:3948</i>
	 */
	ClangLibrary.CXSourceRange.ByValue clang_getTokenExtent(ClangLibrary.CXTranslationUnit CXTranslationUnit1, ClangLibrary.CXToken.ByValue CXToken1);
	/**
	 * \brief Tokenize the source code described by the given range into raw<br>
	 * lexical tokens.<br>
	 * \param TU the translation unit whose text is being tokenized.<br>
	 * \param Range the source range in which text should be tokenized. All of the<br>
	 * tokens produced by tokenization will fall within this source range,<br>
	 * \param Tokens this pointer will be set to point to the array of tokens<br>
	 * that occur within the given source range. The returned pointer must be<br>
	 * freed with clang_disposeTokens() before the translation unit is destroyed.<br>
	 * \param NumTokens will be set to the number of tokens in the \c *Tokens<br>
	 * array.<br>
	 * Original signature : <code>void clang_tokenize(CXTranslationUnit, CXSourceRange, CXToken**, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:3967</i>
	 */
	void clang_tokenize(ClangLibrary.CXTranslationUnit TU, ClangLibrary.CXSourceRange.ByValue Range, ClangLibrary.CXToken.ByReference Tokens[], IntBuffer NumTokens);
	/**
	 * \brief Tokenize the source code described by the given range into raw<br>
	 * lexical tokens.<br>
	 * \param TU the translation unit whose text is being tokenized.<br>
	 * \param Range the source range in which text should be tokenized. All of the<br>
	 * tokens produced by tokenization will fall within this source range,<br>
	 * \param Tokens this pointer will be set to point to the array of tokens<br>
	 * that occur within the given source range. The returned pointer must be<br>
	 * freed with clang_disposeTokens() before the translation unit is destroyed.<br>
	 * \param NumTokens will be set to the number of tokens in the \c *Tokens<br>
	 * array.<br>
	 * Original signature : <code>void clang_tokenize(CXTranslationUnit, CXSourceRange, CXToken**, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:3967</i>
	 */
	void clang_tokenize(Pointer TU, ClangLibrary.CXSourceRange.ByValue Range, ClangLibrary.CXToken.ByReference Tokens[], IntByReference NumTokens);
	/**
	 * \brief Annotate the given set of tokens by providing cursors for each token<br>
	 * that can be mapped to a specific entity within the abstract syntax tree.<br>
	 * This token-annotation routine is equivalent to invoking<br>
	 * clang_getCursor() for the source locations of each of the<br>
	 * tokens. The cursors provided are filtered, so that only those<br>
	 * cursors that have a direct correspondence to the token are<br>
	 * accepted. For example, given a function call \c f(x),<br>
	 * clang_getCursor() would provide the following cursors:<br>
	 *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.<br>
	 * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.<br>
	 * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.<br>
	 * Only the first and last of these cursors will occur within the<br>
	 * annotate, since the tokens "f" and "x' directly refer to a function<br>
	 * and a variable, respectively, but the parentheses are just a small<br>
	 * part of the full syntax of the function call expression, which is<br>
	 * not provided as an annotation.<br>
	 * \param TU the translation unit that owns the given tokens.<br>
	 * \param Tokens the set of tokens to annotate.<br>
	 * \param NumTokens the number of tokens in \p Tokens.<br>
	 * \param Cursors an array of \p NumTokens cursors, whose contents will be<br>
	 * replaced with the cursors corresponding to each token.<br>
	 * Original signature : <code>void clang_annotateTokens(CXTranslationUnit, CXToken*, unsigned, CXCursor*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4000</i>
	 */
	void clang_annotateTokens(ClangLibrary.CXTranslationUnit TU, ClangLibrary.CXToken Tokens, int NumTokens, ClangLibrary.CXCursor Cursors);
	/**
	 * \brief Free the given set of tokens.<br>
	 * Original signature : <code>void clang_disposeTokens(CXTranslationUnit, CXToken*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4007</i>
	 */
	void clang_disposeTokens(ClangLibrary.CXTranslationUnit TU, ClangLibrary.CXToken Tokens, int NumTokens);
	/**
	 * for debug/testing<br>
	 * Original signature : <code>CXString clang_getCursorKindSpelling(CXCursorKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:4024</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCursorKindSpelling(int Kind);
	/**
	 * Original signature : <code>void clang_getDefinitionSpellingAndExtent(CXCursor, const char**, const char**, unsigned*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4025</i>
	 */
	void clang_getDefinitionSpellingAndExtent(ClangLibrary.CXCursor.ByValue CXCursor1, String startBuf[], String endBuf[], IntBuffer startLine, IntBuffer startColumn, IntBuffer endLine, IntBuffer endColumn);
	/**
	 * Original signature : <code>void clang_enableStackTraces()</code><br>
	 * <i>native declaration : clang-c/Index.h:4032</i>
	 */
	void clang_enableStackTraces();
	/**
	 * Original signature : <code>void clang_executeOnThread(clang_executeOnThread_fn_callback*, void*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4033</i>
	 */
	void clang_executeOnThread(ClangLibrary.clang_executeOnThread_fn_callback fn, Pointer user_data, int stack_size);
	/**
	 * \brief Determine the kind of a particular chunk within a completion string.<br>
	 * \param completion_string the completion string to query.<br>
	 * \param chunk_number the 0-based index of the chunk in the completion string.<br>
	 * \returns the kind of the chunk at the index \c chunk_number.<br>
	 * Original signature : <code>CXCompletionChunkKind clang_getCompletionChunkKind(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4270</i>
	 */
	int clang_getCompletionChunkKind(Pointer completion_string, int chunk_number);
	/**
	 * \brief Retrieve the text associated with a particular chunk within a<br>
	 * completion string.<br>
	 * \param completion_string the completion string to query.<br>
	 * \param chunk_number the 0-based index of the chunk in the completion string.<br>
	 * \returns the text associated with the chunk at index \c chunk_number.<br>
	 * Original signature : <code>CXString clang_getCompletionChunkText(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4284</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCompletionChunkText(Pointer completion_string, int chunk_number);
	/**
	 * \brief Retrieve the completion string associated with a particular chunk<br>
	 * within a completion string.<br>
	 * \param completion_string the completion string to query.<br>
	 * \param chunk_number the 0-based index of the chunk in the completion string.<br>
	 * \returns the completion string associated with the chunk at index<br>
	 * \c chunk_number.<br>
	 * Original signature : <code>CXCompletionString clang_getCompletionChunkCompletionString(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4299</i>
	 */
	Pointer clang_getCompletionChunkCompletionString(Pointer completion_string, int chunk_number);
	/**
	 * \brief Retrieve the number of chunks in the given code-completion string.<br>
	 * Original signature : <code>int clang_getNumCompletionChunks(CXCompletionString)</code><br>
	 * <i>native declaration : clang-c/Index.h:4306</i>
	 */
	int clang_getNumCompletionChunks(Pointer completion_string);
	/**
	 * \brief Determine the priority of this code completion.<br>
	 * The priority of a code completion indicates how likely it is that this <br>
	 * particular completion is the completion that the user will select. The<br>
	 * priority is selected by various internal heuristics.<br>
	 * \param completion_string The completion string to query.<br>
	 * \returns The priority of this completion string. Smaller values indicate<br>
	 * higher-priority (more likely) completions.<br>
	 * Original signature : <code>int clang_getCompletionPriority(CXCompletionString)</code><br>
	 * <i>native declaration : clang-c/Index.h:4321</i>
	 */
	int clang_getCompletionPriority(Pointer completion_string);
	/**
	 * \brief Determine the availability of the entity that this code-completion<br>
	 * string refers to.<br>
	 * \param completion_string The completion string to query.<br>
	 * \returns The availability of the completion string.<br>
	 * Original signature : <code>CXAvailabilityKind clang_getCompletionAvailability(CXCompletionString)</code><br>
	 * <i>native declaration : clang-c/Index.h:4332</i>
	 */
	int clang_getCompletionAvailability(Pointer completion_string);
	/**
	 * \brief Retrieve the number of annotations associated with the given<br>
	 * completion string.<br>
	 * \param completion_string the completion string to query.<br>
	 * \returns the number of annotations associated with the given completion<br>
	 * string.<br>
	 * Original signature : <code>int clang_getCompletionNumAnnotations(CXCompletionString)</code><br>
	 * <i>native declaration : clang-c/Index.h:4344</i>
	 */
	int clang_getCompletionNumAnnotations(Pointer completion_string);
	/**
	 * \brief Retrieve the annotation associated with the given completion string.<br>
	 * \param completion_string the completion string to query.<br>
	 * \param annotation_number the 0-based index of the annotation of the<br>
	 * completion string.<br>
	 * \returns annotation string associated with the completion at index<br>
	 * \c annotation_number, or a NULL string if that annotation is not available.<br>
	 * Original signature : <code>CXString clang_getCompletionAnnotation(CXCompletionString, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4358</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCompletionAnnotation(Pointer completion_string, int annotation_number);
	/**
	 * \brief Retrieve the parent context of the given completion string.<br>
	 * The parent context of a completion string is the semantic parent of <br>
	 * the declaration (if any) that the code completion represents. For example,<br>
	 * a code completion for an Objective-C method would have the method's class<br>
	 * or protocol as its context.<br>
	 * \param completion_string The code completion string whose parent is<br>
	 * being queried.<br>
	 * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.<br>
	 * \returns The name of the completion parent, e.g., "NSObject" if<br>
	 * the completion string represents a method in the NSObject class.<br>
	 * Original signature : <code>CXString clang_getCompletionParent(CXCompletionString, CXCursorKind*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4378</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCompletionParent(Pointer completion_string, IntBuffer kind);
	/**
	 * \brief Retrieve the brief documentation comment attached to the declaration<br>
	 * that corresponds to the given completion string.<br>
	 * Original signature : <code>CXString clang_getCompletionBriefComment(CXCompletionString)</code><br>
	 * <i>native declaration : clang-c/Index.h:4386</i>
	 */
	ClangLibrary.CXString.ByValue clang_getCompletionBriefComment(Pointer completion_string);
	/**
	 * \brief Retrieve a completion string for an arbitrary declaration or macro<br>
	 * definition cursor.<br>
	 * \param cursor The cursor to query.<br>
	 * \returns A non-context-sensitive completion string for declaration and macro<br>
	 * definition cursors, or NULL for other kinds of cursors.<br>
	 * Original signature : <code>CXCompletionString clang_getCursorCompletionString(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Index.h:4398</i>
	 */
	Pointer clang_getCursorCompletionString(ClangLibrary.CXCursor.ByValue cursor);
	/**
	 * \brief Returns a default set of code-completion options that can be<br>
	 * passed to\c clang_codeCompleteAt().<br>
	 * Original signature : <code>int clang_defaultCodeCompleteOptions()</code><br>
	 * <i>native declaration : clang-c/Index.h:4583</i>
	 */
	int clang_defaultCodeCompleteOptions();
	/**
	 * \brief Perform code completion at a given location in a translation unit.<br>
	 * This function performs code completion at a particular file, line, and<br>
	 * column within source code, providing results that suggest potential<br>
	 * code snippets based on the context of the completion. The basic model<br>
	 * for code completion is that Clang will parse a complete source file,<br>
	 * performing syntax checking up to the location where code-completion has<br>
	 * been requested. At that point, a special code-completion token is passed<br>
	 * to the parser, which recognizes this token and determines, based on the<br>
	 * current location in the C/Objective-C/C++ grammar and the state of<br>
	 * semantic analysis, what completions to provide. These completions are<br>
	 * returned via a new \c CXCodeCompleteResults structure.<br>
	 * Code completion itself is meant to be triggered by the client when the<br>
	 * user types punctuation characters or whitespace, at which point the<br>
	 * code-completion location will coincide with the cursor. For example, if \c p<br>
	 * is a pointer, code-completion might be triggered after the "-" and then<br>
	 * after the ">" in \c p->. When the code-completion location is afer the ">",<br>
	 * the completion results will provide, e.g., the members of the struct that<br>
	 * "p" points to. The client is responsible for placing the cursor at the<br>
	 * beginning of the token currently being typed, then filtering the results<br>
	 * based on the contents of the token. For example, when code-completing for<br>
	 * the expression \c p->get, the client should provide the location just after<br>
	 * the ">" (e.g., pointing at the "g") to this code-completion hook. Then, the<br>
	 * client can filter the results based on the current token text ("get"), only<br>
	 * showing those results that start with "get". The intent of this interface<br>
	 * is to separate the relatively high-latency acquisition of code-completion<br>
	 * results from the filtering of results on a per-character basis, which must<br>
	 * have a lower latency.<br>
	 * \param TU The translation unit in which code-completion should<br>
	 * occur. The source files for this translation unit need not be<br>
	 * completely up-to-date (and the contents of those source files may<br>
	 * be overridden via \p unsaved_files). Cursors referring into the<br>
	 * translation unit may be invalidated by this invocation.<br>
	 * \param complete_filename The name of the source file where code<br>
	 * completion should be performed. This filename may be any file<br>
	 * included in the translation unit.<br>
	 * \param complete_line The line at which code-completion should occur.<br>
	 * \param complete_column The column at which code-completion should occur.<br>
	 * Note that the column should point just after the syntactic construct that<br>
	 * initiated code completion, and not in the middle of a lexical token.<br>
	 * \param unsaved_files the Tiles that have not yet been saved to disk<br>
	 * but may be required for parsing or code completion, including the<br>
	 * contents of those files.  The contents and name of these files (as<br>
	 * specified by CXUnsavedFile) are copied when necessary, so the<br>
	 * client only needs to guarantee their validity until the call to<br>
	 * this function returns.<br>
	 * \param num_unsaved_files The number of unsaved file entries in \p<br>
	 * unsaved_files.<br>
	 * \param options Extra options that control the behavior of code<br>
	 * completion, expressed as a bitwise OR of the enumerators of the<br>
	 * CXCodeComplete_Flags enumeration. The <br>
	 * \c clang_defaultCodeCompleteOptions() function returns a default set<br>
	 * of code-completion options.<br>
	 * \returns If successful, a new \c CXCodeCompleteResults structure<br>
	 * containing code-completion results, which should eventually be<br>
	 * freed with \c clang_disposeCodeCompleteResults(). If code<br>
	 * completion fails, returns NULL.<br>
	 * Original signature : <code>CXCodeCompleteResults* clang_codeCompleteAt(CXTranslationUnit, const char*, unsigned, unsigned, CXUnsavedFile*, unsigned, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4654</i>
	 */
	ClangLibrary.CXCodeCompleteResults clang_codeCompleteAt(ClangLibrary.CXTranslationUnit TU, String complete_filename, int complete_line, int complete_column, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, int options);
	/**
	 * \brief Sort the code-completion results in case-insensitive alphabetical <br>
	 * order.<br>
	 * \param Results The set of results to sort.<br>
	 * \param NumResults The number of results in \p Results.<br>
	 * Original signature : <code>void clang_sortCodeCompletionResults(CXCompletionResult*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4670</i>
	 */
	void clang_sortCodeCompletionResults(ClangLibrary.CXCompletionResult Results, int NumResults);
	/**
	 * \brief Free the given set of code-completion results.<br>
	 * Original signature : <code>void clang_disposeCodeCompleteResults(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4677</i>
	 */
	void clang_disposeCodeCompleteResults(ClangLibrary.CXCodeCompleteResults Results);
	/**
	 * \brief Determine the number of diagnostics produced prior to the<br>
	 * location where code completion was performed.<br>
	 * Original signature : <code>int clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4684</i>
	 */
	int clang_codeCompleteGetNumDiagnostics(ClangLibrary.CXCodeCompleteResults Results);
	/**
	 * \brief Retrieve a diagnostic associated with the given code completion.<br>
	 * \param Results the code completion results to query.<br>
	 * \param Index the zero-based diagnostic number to retrieve.<br>
	 * \returns the requested diagnostic. This diagnostic must be freed<br>
	 * via a call to \c clang_disposeDiagnostic().<br>
	 * Original signature : <code>CXDiagnostic clang_codeCompleteGetDiagnostic(CXCodeCompleteResults*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4696</i>
	 */
	Pointer clang_codeCompleteGetDiagnostic(ClangLibrary.CXCodeCompleteResults Results, int Index);
	/**
	 * \brief Determines what completions are appropriate for the context<br>
	 * the given code completion.<br>
	 * <br>
	 * \param Results the code completion results to query<br>
	 * \returns the kinds of completions that are appropriate for use<br>
	 * along with the given code completion results.<br>
	 * Original signature : <code>long long clang_codeCompleteGetContexts(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4709</i>
	 */
	long clang_codeCompleteGetContexts(ClangLibrary.CXCodeCompleteResults Results);
	/**
	 * \brief Returns the cursor kind for the container for the current code<br>
	 * completion context. The container is only guaranteed to be set for<br>
	 * contexts where a container exists (i.e. member accesses or Objective-C<br>
	 * message sends); if there is not a container, this function will return<br>
	 * CXCursor_InvalidCode.<br>
	 * \param Results the code completion results to query<br>
	 * \param IsIncomplete on return, this value will be false if Clang has complete<br>
	 * information about the container. If Clang does not have complete<br>
	 * information, this value will be true.<br>
	 * \returns the container kind, or CXCursor_InvalidCode if there is not a<br>
	 * container<br>
	 * Original signature : <code>CXCursorKind clang_codeCompleteGetContainerKind(CXCodeCompleteResults*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4729</i>
	 */
	int clang_codeCompleteGetContainerKind(ClangLibrary.CXCodeCompleteResults Results, IntBuffer IsIncomplete);
	/**
	 * \brief Returns the USR for the container for the current code completion<br>
	 * context. If there is not a container for the current context, this<br>
	 * function will return the empty string.<br>
	 * \param Results the code completion results to query<br>
	 * \returns the USR for the container<br>
	 * Original signature : <code>CXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4743</i>
	 */
	ClangLibrary.CXString.ByValue clang_codeCompleteGetContainerUSR(ClangLibrary.CXCodeCompleteResults Results);
	/**
	 * \brief Returns the currently-entered selector for an Objective-C message<br>
	 * send, formatted like "initWithFoo:bar:". Only guaranteed to return a<br>
	 * non-empty string for CXCompletionContext_ObjCInstanceMessage and<br>
	 * CXCompletionContext_ObjCClassMessage.<br>
	 * \param Results the code completion results to query<br>
	 * \returns the selector (or partial selector) that has been entered thus far<br>
	 * for an Objective-C message send.<br>
	 * Original signature : <code>CXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4758</i>
	 */
	ClangLibrary.CXString.ByValue clang_codeCompleteGetObjCSelector(ClangLibrary.CXCodeCompleteResults Results);
	/**
	 * \brief Return a version string, suitable for showing to a user, but not<br>
	 *        intended to be parsed (the format is not guaranteed to be stable).<br>
	 * Original signature : <code>CXString clang_getClangVersion()</code><br>
	 * <i>native declaration : clang-c/Index.h:4775</i>
	 */
	ClangLibrary.CXString.ByValue clang_getClangVersion();
	/**
	 * \brief Enable/disable crash recovery.<br>
	 * \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero<br>
	 *        value enables crash recovery, while 0 disables it.<br>
	 * Original signature : <code>void clang_toggleCrashRecovery(unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4784</i>
	 */
	void clang_toggleCrashRecovery(int isEnabled);
	/**
	 * \brief Visit the set of preprocessor inclusions in a translation unit.<br>
	 *   The visitor function is called with the provided data for every included<br>
	 *   file.  This does not include headers included by the PCH file (unless one<br>
	 *   is inspecting the inclusions in the PCH file itself).<br>
	 * Original signature : <code>void clang_getInclusions(CXTranslationUnit, CXInclusionVisitor, CXClientData)</code><br>
	 * <i>native declaration : clang-c/Index.h:4808</i>
	 */
	void clang_getInclusions(ClangLibrary.CXTranslationUnit tu, ClangLibrary.CXInclusionVisitor visitor, Pointer client_data);
	/**
	 * \brief Retrieve a remapping.<br>
	 * \param path the path that contains metadata about remappings.<br>
	 * \returns the requested remapping. This remapping must be freed<br>
	 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.<br>
	 * Original signature : <code>CXRemapping clang_getRemappings(const char*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4834</i>
	 */
	Pointer clang_getRemappings(String path);
	/**
	 * \brief Retrieve a remapping.<br>
	 * \param filePaths pointer to an array of file paths containing remapping info.<br>
	 * \param numFiles number of file paths.<br>
	 * \returns the requested remapping. This remapping must be freed<br>
	 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.<br>
	 * Original signature : <code>CXRemapping clang_getRemappingsFromFileList(const char**, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:4847</i>
	 */
	Pointer clang_getRemappingsFromFileList(String filePaths[], int numFiles);
	/**
	 * \brief Determine the number of remappings.<br>
	 * Original signature : <code>int clang_remap_getNumFiles(CXRemapping)</code><br>
	 * <i>native declaration : clang-c/Index.h:4853</i>
	 */
	int clang_remap_getNumFiles(Pointer CXRemapping1);
	/**
	 * \brief Get the original and the associated filename from the remapping.<br>
	 * <br>
	 * \param original If non-NULL, will be set to the original filename.<br>
	 * \param transformed If non-NULL, will be set to the filename that the original<br>
	 * is associated with.<br>
	 * Original signature : <code>void clang_remap_getFilenames(CXRemapping, unsigned, CXString*, CXString*)</code><br>
	 * <i>native declaration : clang-c/Index.h:4863</i>
	 */
	void clang_remap_getFilenames(Pointer CXRemapping1, int index, ClangLibrary.CXString original, ClangLibrary.CXString transformed);
	/**
	 * \brief Dispose the remapping.<br>
	 * Original signature : <code>void clang_remap_dispose(CXRemapping)</code><br>
	 * <i>native declaration : clang-c/Index.h:4869</i>
	 */
	void clang_remap_dispose(Pointer CXRemapping1);
	/**
	 * \brief Find references of a declaration in a specific file.<br>
	 * <br>
	 * \param cursor pointing to a declaration or a reference of one.<br>
	 * \param file to search for references.<br>
	 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for<br>
	 * each reference found.<br>
	 * The CXSourceRange will point inside the file; if the reference is inside<br>
	 * a macro (and not a macro argument) the CXSourceRange will be invalid.<br>
	 * \returns one of the CXResult enumerators.<br>
	 * Original signature : <code>CXResult clang_findReferencesInFile(CXCursor, CXFile, CXCursorAndRangeVisitor)</code><br>
	 * <i>native declaration : clang-c/Index.h:4921</i>
	 */
	int clang_findReferencesInFile(ClangLibrary.CXCursor.ByValue cursor, Pointer file, ClangLibrary.CXCursorAndRangeVisitor.ByValue visitor);
	/**
	 * \brief Find #import/#include directives in a specific file.<br>
	 * \param TU translation unit containing the file to query.<br>
	 * \param file to search for #import/#include directives.<br>
	 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for<br>
	 * each directive found.<br>
	 * \returns one of the CXResult enumerators.<br>
	 * Original signature : <code>CXResult clang_findIncludesInFile(CXTranslationUnit, CXFile, CXCursorAndRangeVisitor)</code><br>
	 * <i>native declaration : clang-c/Index.h:4936</i>
	 */
	int clang_findIncludesInFile(ClangLibrary.CXTranslationUnit TU, Pointer file, ClangLibrary.CXCursorAndRangeVisitor.ByValue visitor);
	/**
	 * Original signature : <code>int clang_index_isEntityObjCContainerKind(CXIdxEntityKind)</code><br>
	 * <i>native declaration : clang-c/Index.h:5315</i>
	 */
	int clang_index_isEntityObjCContainerKind(int CXIdxEntityKind1);
	/**
	 * Original signature : <code>CXIdxObjCContainerDeclInfo* clang_index_getObjCContainerDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5316</i>
	 */
	ClangLibrary.CXIdxObjCContainerDeclInfo clang_index_getObjCContainerDeclInfo(ClangLibrary.CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCInterfaceDeclInfo* clang_index_getObjCInterfaceDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5319</i>
	 */
	ClangLibrary.CXIdxObjCInterfaceDeclInfo clang_index_getObjCInterfaceDeclInfo(ClangLibrary.CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCCategoryDeclInfo* clang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5323</i>
	 */
	ClangLibrary.CXIdxObjCCategoryDeclInfo clang_index_getObjCCategoryDeclInfo(ClangLibrary.CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCProtocolRefListInfo* clang_index_getObjCProtocolRefListInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5326</i>
	 */
	ClangLibrary.CXIdxObjCProtocolRefListInfo clang_index_getObjCProtocolRefListInfo(ClangLibrary.CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxObjCPropertyDeclInfo* clang_index_getObjCPropertyDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5329</i>
	 */
	ClangLibrary.CXIdxObjCPropertyDeclInfo clang_index_getObjCPropertyDeclInfo(ClangLibrary.CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * Original signature : <code>CXIdxIBOutletCollectionAttrInfo* clang_index_getIBOutletCollectionAttrInfo(const CXIdxAttrInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5332</i>
	 */
	ClangLibrary.CXIdxIBOutletCollectionAttrInfo clang_index_getIBOutletCollectionAttrInfo(ClangLibrary.CXIdxAttrInfo CXIdxAttrInfoPtr1);
	/**
	 * Original signature : <code>CXIdxCXXClassDeclInfo* clang_index_getCXXClassDeclInfo(const CXIdxDeclInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5335</i>
	 */
	ClangLibrary.CXIdxCXXClassDeclInfo clang_index_getCXXClassDeclInfo(ClangLibrary.CXIdxDeclInfo CXIdxDeclInfoPtr1);
	/**
	 * \brief For retrieving a custom CXIdxClientContainer attached to a<br>
	 * container.<br>
	 * Original signature : <code>CXIdxClientContainer clang_index_getClientContainer(const CXIdxContainerInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5342</i>
	 */
	Pointer clang_index_getClientContainer(ClangLibrary.CXIdxContainerInfo CXIdxContainerInfoPtr1);
	/**
	 * \brief For setting a custom CXIdxClientContainer attached to a<br>
	 * container.<br>
	 * Original signature : <code>void clang_index_setClientContainer(const CXIdxContainerInfo*, CXIdxClientContainer)</code><br>
	 * <i>native declaration : clang-c/Index.h:5349</i>
	 */
	void clang_index_setClientContainer(ClangLibrary.CXIdxContainerInfo CXIdxContainerInfoPtr1, Pointer CXIdxClientContainer1);
	/**
	 * \brief For retrieving a custom CXIdxClientEntity attached to an entity.<br>
	 * Original signature : <code>CXIdxClientEntity clang_index_getClientEntity(const CXIdxEntityInfo*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5355</i>
	 */
	Pointer clang_index_getClientEntity(ClangLibrary.CXIdxEntityInfo CXIdxEntityInfoPtr1);
	/**
	 * \brief For setting a custom CXIdxClientEntity attached to an entity.<br>
	 * Original signature : <code>void clang_index_setClientEntity(const CXIdxEntityInfo*, CXIdxClientEntity)</code><br>
	 * <i>native declaration : clang-c/Index.h:5361</i>
	 */
	void clang_index_setClientEntity(ClangLibrary.CXIdxEntityInfo CXIdxEntityInfoPtr1, Pointer CXIdxClientEntity1);
	/**
	 * \brief An indexing action/session, to be applied to one or multiple<br>
	 * translation units.<br>
	 * \param CIdx The index object with which the index action will be associated.<br>
	 * Original signature : <code>CXIndexAction clang_IndexAction_create(CXIndex)</code><br>
	 * <i>native declaration : clang-c/Index.h:5376</i>
	 */
	Pointer clang_IndexAction_create(Pointer CIdx);
	/**
	 * \brief Destroy the given index action.<br>
	 * The index action must not be destroyed until all of the translation units<br>
	 * created within that index action have been destroyed.<br>
	 * Original signature : <code>void clang_IndexAction_dispose(CXIndexAction)</code><br>
	 * <i>native declaration : clang-c/Index.h:5384</i>
	 */
	void clang_IndexAction_dispose(Pointer CXIndexAction1);
	/**
	 * \brief Index the given source file and the translation unit corresponding<br>
	 * to that file via callbacks implemented through #IndexerCallbacks.<br>
	 * \param client_data pointer data supplied by the client, which will<br>
	 * be passed to the invoked callbacks.<br>
	 * \param index_callbacks Pointer to indexing callbacks that the client<br>
	 * implements.<br>
	 * \param index_callbacks_size Size of #IndexerCallbacks structure that gets<br>
	 * passed in index_callbacks.<br>
	 * \param index_options A bitmask of options that affects how indexing is<br>
	 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.<br>
	 * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be<br>
	 * reused after indexing is finished. Set to \c NULL if you do not require it.<br>
	 * \returns 0 on success or if there were errors from which the compiler could<br>
	 * recover.  If there is a failure from which the there is no recovery, returns<br>
	 * a non-zero \c CXErrorCode.<br>
	 * The rest of the parameters are the same as #clang_parseTranslationUnit.<br>
	 * Original signature : <code>int clang_indexSourceFile(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, const char*, const const char**, int, CXUnsavedFile*, unsigned, CXTranslationUnit*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:5450</i>
	 */
	int clang_indexSourceFile(Pointer CXIndexAction1, Pointer client_data, ClangLibrary.IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, String source_filename, String command_line_args[], int num_command_line_args, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, PointerByReference out_TU, int TU_options);
	/**
	 * \brief Index the given source file and the translation unit corresponding<br>
	 * to that file via callbacks implemented through #IndexerCallbacks.<br>
	 * \param client_data pointer data supplied by the client, which will<br>
	 * be passed to the invoked callbacks.<br>
	 * \param index_callbacks Pointer to indexing callbacks that the client<br>
	 * implements.<br>
	 * \param index_callbacks_size Size of #IndexerCallbacks structure that gets<br>
	 * passed in index_callbacks.<br>
	 * \param index_options A bitmask of options that affects how indexing is<br>
	 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.<br>
	 * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be<br>
	 * reused after indexing is finished. Set to \c NULL if you do not require it.<br>
	 * \returns 0 on success or if there were errors from which the compiler could<br>
	 * recover.  If there is a failure from which the there is no recovery, returns<br>
	 * a non-zero \c CXErrorCode.<br>
	 * The rest of the parameters are the same as #clang_parseTranslationUnit.<br>
	 * Original signature : <code>int clang_indexSourceFile(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, const char*, const const char**, int, CXUnsavedFile*, unsigned, CXTranslationUnit*, unsigned)</code><br>
	 * <i>native declaration : clang-c/Index.h:5450</i>
	 */
	int clang_indexSourceFile(Pointer CXIndexAction1, Pointer client_data, ClangLibrary.IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, Pointer source_filename, PointerByReference command_line_args, int num_command_line_args, ClangLibrary.CXUnsavedFile unsaved_files, int num_unsaved_files, PointerByReference out_TU, int TU_options);
	/**
	 * \brief Index the given translation unit via callbacks implemented through<br>
	 * #IndexerCallbacks.<br>
	 * <br>
	 * The order of callback invocations is not guaranteed to be the same as<br>
	 * when indexing a source file. The high level order will be:<br>
	 * <br>
	 *   -Preprocessor callbacks invocations<br>
	 *   -Declaration/reference callbacks invocations<br>
	 *   -Diagnostic callback invocations<br>
	 * The parameters are the same as #clang_indexSourceFile.<br>
	 * <br>
	 * \returns If there is a failure from which the there is no recovery, returns<br>
	 * non-zero, otherwise returns 0.<br>
	 * Original signature : <code>int clang_indexTranslationUnit(CXIndexAction, CXClientData, IndexerCallbacks*, unsigned, unsigned, CXTranslationUnit)</code><br>
	 * <i>native declaration : clang-c/Index.h:5479</i>
	 */
	int clang_indexTranslationUnit(Pointer CXIndexAction1, Pointer client_data, ClangLibrary.IndexerCallbacks index_callbacks, int index_callbacks_size, int index_options, ClangLibrary.CXTranslationUnit CXTranslationUnit1);
	/**
	 * \brief Retrieve the CXIdxFile, file, line, column, and offset represented by<br>
	 * the given CXIdxLoc.<br>
	 * If the location refers into a macro expansion, retrieves the<br>
	 * location of the macro expansion and if it refers into a macro argument<br>
	 * retrieves the location of the argument.<br>
	 * Original signature : <code>void clang_indexLoc_getFileLocation(CXIdxLoc, CXIdxClientFile*, CXFile*, unsigned*, unsigned*, unsigned*)</code><br>
	 * <i>native declaration : clang-c/Index.h:5494</i>
	 */
	void clang_indexLoc_getFileLocation(ClangLibrary.CXIdxLoc.ByValue loc, PointerByReference indexFile, PointerByReference file, IntBuffer line, IntBuffer column, IntBuffer offset);
	/**
	 * \brief Retrieve the CXSourceLocation represented by the given CXIdxLoc.<br>
	 * Original signature : <code>CXSourceLocation clang_indexLoc_getCXSourceLocation(CXIdxLoc)</code><br>
	 * <i>native declaration : clang-c/Index.h:5505</i>
	 */
	ClangLibrary.CXSourceLocation.ByValue clang_indexLoc_getCXSourceLocation(ClangLibrary.CXIdxLoc.ByValue loc);
	/**
	 * \brief Given a cursor that represents a documentable entity (e.g.,<br>
	 * declaration), return the associated parsed comment as a<br>
	 * \c CXComment_FullComment AST node.<br>
	 * Original signature : <code>CXComment clang_Cursor_getParsedComment(CXCursor)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:46</i>
	 */
	ClangLibrary.CXComment.ByValue clang_Cursor_getParsedComment(ClangLibrary.CXCursor.ByValue C);
	/**
	 * \param Comment AST node of any kind.<br>
	 * \returns the type of the AST node.<br>
	 * Original signature : <code>CXCommentKind clang_Comment_getKind(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:212</i>
	 */
	int clang_Comment_getKind(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment AST node of any kind.<br>
	 * \returns number of children of the AST node.<br>
	 * Original signature : <code>int clang_Comment_getNumChildren(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:219</i>
	 */
	int clang_Comment_getNumChildren(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment AST node of any kind.<br>
	 * \param ChildIdx child index (zero-based).<br>
	 * \returns the specified child of the AST node.<br>
	 * Original signature : <code>CXComment clang_Comment_getChild(CXComment, unsigned)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:229</i>
	 */
	ClangLibrary.CXComment.ByValue clang_Comment_getChild(ClangLibrary.CXComment.ByValue Comment, int ChildIdx);
	/**
	 * \brief A \c CXComment_Paragraph node is considered whitespace if it contains<br>
	 * only \c CXComment_Text nodes that are empty or whitespace.<br>
	 * Other AST nodes (except \c CXComment_Paragraph and \c CXComment_Text) are<br>
	 * never considered whitespace.<br>
	 * \returns non-zero if \c Comment is whitespace.<br>
	 * Original signature : <code>int clang_Comment_isWhitespace(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:240</i>
	 */
	int clang_Comment_isWhitespace(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \returns non-zero if \c Comment is inline content and has a newline<br>
	 * immediately following it in the comment text.  Newlines between paragraphs<br>
	 * do not count.<br>
	 * Original signature : <code>int clang_InlineContentComment_hasTrailingNewline(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:248</i>
	 */
	int clang_InlineContentComment_hasTrailingNewline(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_Text AST node.<br>
	 * \returns text contained in the AST node.<br>
	 * Original signature : <code>CXString clang_TextComment_getText(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:255</i>
	 */
	ClangLibrary.CXString.ByValue clang_TextComment_getText(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_InlineCommand AST node.<br>
	 * \returns name of the inline command.<br>
	 * Original signature : <code>CXString clang_InlineCommandComment_getCommandName(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:263</i>
	 */
	ClangLibrary.CXString.ByValue clang_InlineCommandComment_getCommandName(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_InlineCommand AST node.<br>
	 * \returns the most appropriate rendering mode, chosen on command<br>
	 * semantics in Doxygen.<br>
	 * Original signature : <code>CXCommentInlineCommandRenderKind clang_InlineCommandComment_getRenderKind(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:271</i>
	 */
	int clang_InlineCommandComment_getRenderKind(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_InlineCommand AST node.<br>
	 * \returns number of command arguments.<br>
	 * Original signature : <code>int clang_InlineCommandComment_getNumArgs(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:280</i>
	 */
	int clang_InlineCommandComment_getNumArgs(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_InlineCommand AST node.<br>
	 * \param ArgIdx argument index (zero-based).<br>
	 * \returns text of the specified argument.<br>
	 * Original signature : <code>CXString clang_InlineCommandComment_getArgText(CXComment, unsigned)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:290</i>
	 */
	ClangLibrary.CXString.ByValue clang_InlineCommandComment_getArgText(ClangLibrary.CXComment.ByValue Comment, int ArgIdx);
	/**
	 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST<br>
	 * node.<br>
	 * \returns HTML tag name.<br>
	 * Original signature : <code>CXString clang_HTMLTagComment_getTagName(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:299</i>
	 */
	ClangLibrary.CXString.ByValue clang_HTMLTagComment_getTagName(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_HTMLStartTag AST node.<br>
	 * \returns non-zero if tag is self-closing (for example, &lt;br /&gt;).<br>
	 * Original signature : <code>int clang_HTMLStartTagComment_isSelfClosing(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:307</i>
	 */
	int clang_HTMLStartTagComment_isSelfClosing(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_HTMLStartTag AST node.<br>
	 * \returns number of attributes (name-value pairs) attached to the start tag.<br>
	 * Original signature : <code>int clang_HTMLStartTag_getNumAttrs(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:314</i>
	 */
	int clang_HTMLStartTag_getNumAttrs(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_HTMLStartTag AST node.<br>
	 * \param AttrIdx attribute index (zero-based).<br>
	 * \returns name of the specified attribute.<br>
	 * Original signature : <code>CXString clang_HTMLStartTag_getAttrName(CXComment, unsigned)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:324</i>
	 */
	ClangLibrary.CXString.ByValue clang_HTMLStartTag_getAttrName(ClangLibrary.CXComment.ByValue Comment, int AttrIdx);
	/**
	 * \param Comment a \c CXComment_HTMLStartTag AST node.<br>
	 * \param AttrIdx attribute index (zero-based).<br>
	 * \returns value of the specified attribute.<br>
	 * Original signature : <code>CXString clang_HTMLStartTag_getAttrValue(CXComment, unsigned)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:334</i>
	 */
	ClangLibrary.CXString.ByValue clang_HTMLStartTag_getAttrValue(ClangLibrary.CXComment.ByValue Comment, int AttrIdx);
	/**
	 * \param Comment a \c CXComment_BlockCommand AST node.<br>
	 * \returns name of the block command.<br>
	 * Original signature : <code>CXString clang_BlockCommandComment_getCommandName(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:342</i>
	 */
	ClangLibrary.CXString.ByValue clang_BlockCommandComment_getCommandName(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_BlockCommand AST node.<br>
	 * \returns number of word-like arguments.<br>
	 * Original signature : <code>int clang_BlockCommandComment_getNumArgs(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:350</i>
	 */
	int clang_BlockCommandComment_getNumArgs(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_BlockCommand AST node.<br>
	 * \param ArgIdx argument index (zero-based).<br>
	 * \returns text of the specified word-like argument.<br>
	 * Original signature : <code>CXString clang_BlockCommandComment_getArgText(CXComment, unsigned)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:360</i>
	 */
	ClangLibrary.CXString.ByValue clang_BlockCommandComment_getArgText(ClangLibrary.CXComment.ByValue Comment, int ArgIdx);
	/**
	 * \param Comment a \c CXComment_BlockCommand or<br>
	 * \c CXComment_VerbatimBlockCommand AST node.<br>
	 * \returns paragraph argument of the block command.<br>
	 * Original signature : <code>CXComment clang_BlockCommandComment_getParagraph(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:370</i>
	 */
	ClangLibrary.CXComment.ByValue clang_BlockCommandComment_getParagraph(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_ParamCommand AST node.<br>
	 * \returns parameter name.<br>
	 * Original signature : <code>CXString clang_ParamCommandComment_getParamName(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:378</i>
	 */
	ClangLibrary.CXString.ByValue clang_ParamCommandComment_getParamName(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_ParamCommand AST node.<br>
	 * \returns non-zero if the parameter that this AST node represents was found<br>
	 * in the function prototype and \c clang_ParamCommandComment_getParamIndex<br>
	 * function will return a meaningful value.<br>
	 * Original signature : <code>int clang_ParamCommandComment_isParamIndexValid(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:388</i>
	 */
	int clang_ParamCommandComment_isParamIndexValid(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_ParamCommand AST node.<br>
	 * \returns zero-based parameter index in function prototype.<br>
	 * Original signature : <code>int clang_ParamCommandComment_getParamIndex(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:396</i>
	 */
	int clang_ParamCommandComment_getParamIndex(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_ParamCommand AST node.<br>
	 * \returns non-zero if parameter passing direction was specified explicitly in<br>
	 * the comment.<br>
	 * Original signature : <code>int clang_ParamCommandComment_isDirectionExplicit(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:405</i>
	 */
	int clang_ParamCommandComment_isDirectionExplicit(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_ParamCommand AST node.<br>
	 * \returns parameter passing direction.<br>
	 * Original signature : <code>CXCommentParamPassDirection clang_ParamCommandComment_getDirection(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:413</i>
	 */
	int clang_ParamCommandComment_getDirection(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_TParamCommand AST node.<br>
	 * \returns template parameter name.<br>
	 * Original signature : <code>CXString clang_TParamCommandComment_getParamName(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:422</i>
	 */
	ClangLibrary.CXString.ByValue clang_TParamCommandComment_getParamName(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_TParamCommand AST node.<br>
	 * \returns non-zero if the parameter that this AST node represents was found<br>
	 * in the template parameter list and<br>
	 * \c clang_TParamCommandComment_getDepth and<br>
	 * \c clang_TParamCommandComment_getIndex functions will return a meaningful<br>
	 * value.<br>
	 * Original signature : <code>int clang_TParamCommandComment_isParamPositionValid(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:434</i>
	 */
	int clang_TParamCommandComment_isParamPositionValid(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_TParamCommand AST node.<br>
	 * \returns zero-based nesting depth of this parameter in the template parameter list.<br>
	 * For example,<br>
	 * \verbatim<br>
	 *     template<typename C, template<typename T> class TT><br>
	 *     void test(TT<int> aaa);<br>
	 * \endverbatim<br>
	 * for C and TT nesting depth is 0,<br>
	 * for T nesting depth is 1.<br>
	 * Original signature : <code>int clang_TParamCommandComment_getDepth(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:450</i>
	 */
	int clang_TParamCommandComment_getDepth(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_TParamCommand AST node.<br>
	 * \returns zero-based parameter index in the template parameter list at a<br>
	 * given nesting depth.<br>
	 * For example,<br>
	 * \verbatim<br>
	 *     template<typename C, template<typename T> class TT><br>
	 *     void test(TT<int> aaa);<br>
	 * \endverbatim<br>
	 * for C and TT nesting depth is 0, so we can ask for index at depth 0:<br>
	 * at depth 0 C's index is 0, TT's index is 1.<br>
	 * For T nesting depth is 1, so we can ask for index at depth 0 and 1:<br>
	 * at depth 0 T's index is 1 (same as TT's),<br>
	 * at depth 1 T's index is 0.<br>
	 * Original signature : <code>int clang_TParamCommandComment_getIndex(CXComment, unsigned)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:471</i>
	 */
	int clang_TParamCommandComment_getIndex(ClangLibrary.CXComment.ByValue Comment, int Depth);
	/**
	 * \param Comment a \c CXComment_VerbatimBlockLine AST node.<br>
	 * \returns text contained in the AST node.<br>
	 * Original signature : <code>CXString clang_VerbatimBlockLineComment_getText(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:479</i>
	 */
	ClangLibrary.CXString.ByValue clang_VerbatimBlockLineComment_getText(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \param Comment a \c CXComment_VerbatimLine AST node.<br>
	 * \returns text contained in the AST node.<br>
	 * Original signature : <code>CXString clang_VerbatimLineComment_getText(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:486</i>
	 */
	ClangLibrary.CXString.ByValue clang_VerbatimLineComment_getText(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \brief Convert an HTML tag AST node to string.<br>
	 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST<br>
	 * node.<br>
	 * \returns string containing an HTML tag.<br>
	 * Original signature : <code>CXString clang_HTMLTagComment_getAsString(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:496</i>
	 */
	ClangLibrary.CXString.ByValue clang_HTMLTagComment_getAsString(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \brief Convert a given full parsed comment to an HTML fragment.<br>
	 * Specific details of HTML layout are subject to change.  Don't try to parse<br>
	 * this HTML back into an AST, use other APIs instead.<br>
	 * Currently the following CSS classes are used:<br>
	 * \li "para-brief" for \\brief paragraph and equivalent commands;<br>
	 * \li "para-returns" for \\returns paragraph and equivalent commands;<br>
	 * \li "word-returns" for the "Returns" word in \\returns paragraph.<br>
	 * Function argument documentation is rendered as a \<dl\> list with arguments<br>
	 * sorted in function prototype order.  CSS classes used:<br>
	 * \li "param-name-index-NUMBER" for parameter name (\<dt\>);<br>
	 * \li "param-descr-index-NUMBER" for parameter description (\<dd\>);<br>
	 * \li "param-name-index-invalid" and "param-descr-index-invalid" are used if<br>
	 * parameter index is invalid.<br>
	 * Template parameter documentation is rendered as a \<dl\> list with<br>
	 * parameters sorted in template parameter list order.  CSS classes used:<br>
	 * \li "tparam-name-index-NUMBER" for parameter name (\<dt\>);<br>
	 * \li "tparam-descr-index-NUMBER" for parameter description (\<dd\>);<br>
	 * \li "tparam-name-index-other" and "tparam-descr-index-other" are used for<br>
	 * names inside template template parameters;<br>
	 * \li "tparam-name-index-invalid" and "tparam-descr-index-invalid" are used if<br>
	 * parameter position is invalid.<br>
	 * \param Comment a \c CXComment_FullComment AST node.<br>
	 * \returns string containing an HTML fragment.<br>
	 * Original signature : <code>CXString clang_FullComment_getAsHTML(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:529</i>
	 */
	ClangLibrary.CXString.ByValue clang_FullComment_getAsHTML(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \brief Convert a given full parsed comment to an XML document.<br>
	 * A Relax NG schema for the XML can be found in comment-xml-schema.rng file<br>
	 * inside clang source tree.<br>
	 * \param Comment a \c CXComment_FullComment AST node.<br>
	 * \returns string containing an XML document.<br>
	 * Original signature : <code>CXString clang_FullComment_getAsXML(CXComment)</code><br>
	 * <i>native declaration : clang-c/Documentation.h:541</i>
	 */
	ClangLibrary.CXString.ByValue clang_FullComment_getAsXML(ClangLibrary.CXComment.ByValue Comment);
	/**
	 * \brief Creates a compilation database from the database found in directory<br>
	 * buildDir. For example, CMake can output a compile_commands.json which can<br>
	 * be used to build the database.<br>
	 * It must be freed by \c clang_CompilationDatabase_dispose.<br>
	 * Original signature : <code>CXCompilationDatabase clang_CompilationDatabase_fromDirectory(const char*, CXCompilationDatabase_Error*)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:60</i>
	 */
	Pointer clang_CompilationDatabase_fromDirectory(String BuildDir, IntBuffer ErrorCode);
	/**
	 * \brief Free the given compilation database<br>
	 * Original signature : <code>void clang_CompilationDatabase_dispose(CXCompilationDatabase)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:67</i>
	 */
	void clang_CompilationDatabase_dispose(Pointer CXCompilationDatabase1);
	/**
	 * \brief Find the compile commands used for a file. The compile commands<br>
	 * must be freed by \c clang_CompileCommands_dispose.<br>
	 * Original signature : <code>CXCompileCommands clang_CompilationDatabase_getCompileCommands(CXCompilationDatabase, const char*)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:74</i>
	 */
	Pointer clang_CompilationDatabase_getCompileCommands(Pointer CXCompilationDatabase1, String CompleteFileName);
	/**
	 * \brief Get all the compile commands in the given compilation database.<br>
	 * Original signature : <code>CXCompileCommands clang_CompilationDatabase_getAllCompileCommands(CXCompilationDatabase)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:81</i>
	 */
	Pointer clang_CompilationDatabase_getAllCompileCommands(Pointer CXCompilationDatabase1);
	/**
	 * \brief Free the given CompileCommands<br>
	 * Original signature : <code>void clang_CompileCommands_dispose(CXCompileCommands)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:87</i>
	 */
	void clang_CompileCommands_dispose(Pointer CXCompileCommands1);
	/**
	 * \brief Get the number of CompileCommand we have for a file<br>
	 * Original signature : <code>int clang_CompileCommands_getSize(CXCompileCommands)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:92</i>
	 */
	int clang_CompileCommands_getSize(Pointer CXCompileCommands1);
	/**
	 * \brief Get the I'th CompileCommand for a file<br>
	 * Note : 0 <= i < clang_CompileCommands_getSize(CXCompileCommands)<br>
	 * Original signature : <code>CXCompileCommand clang_CompileCommands_getCommand(CXCompileCommands, unsigned)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:100</i>
	 */
	Pointer clang_CompileCommands_getCommand(Pointer CXCompileCommands1, int I);
	/**
	 * \brief Get the working directory where the CompileCommand was executed from<br>
	 * Original signature : <code>CXString clang_CompileCommand_getDirectory(CXCompileCommand)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:106</i>
	 */
	ClangLibrary.CXString.ByValue clang_CompileCommand_getDirectory(Pointer CXCompileCommand1);
	/**
	 * \brief Get the number of arguments in the compiler invocation.<br>
	 * Original signature : <code>int clang_CompileCommand_getNumArgs(CXCompileCommand)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:113</i>
	 */
	int clang_CompileCommand_getNumArgs(Pointer CXCompileCommand1);
	/**
	 * \brief Get the I'th argument value in the compiler invocations<br>
	 * Invariant :<br>
	 *  - argument 0 is the compiler executable<br>
	 * Original signature : <code>CXString clang_CompileCommand_getArg(CXCompileCommand, unsigned)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:122</i>
	 */
	ClangLibrary.CXString.ByValue clang_CompileCommand_getArg(Pointer CXCompileCommand1, int I);
	/**
	 * \brief Get the number of source mappings for the compiler invocation.<br>
	 * Original signature : <code>int clang_CompileCommand_getNumMappedSources(CXCompileCommand)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:128</i>
	 */
	int clang_CompileCommand_getNumMappedSources(Pointer CXCompileCommand1);
	/**
	 * \brief Get the I'th mapped source path for the compiler invocation.<br>
	 * Original signature : <code>CXString clang_CompileCommand_getMappedSourcePath(CXCompileCommand, unsigned)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:134</i>
	 */
	ClangLibrary.CXString.ByValue clang_CompileCommand_getMappedSourcePath(Pointer CXCompileCommand1, int I);
	/**
	 * \brief Get the I'th mapped source content for the compiler invocation.<br>
	 * Original signature : <code>CXString clang_CompileCommand_getMappedSourceContent(CXCompileCommand, unsigned)</code><br>
	 * <i>native declaration : clang-c/CXCompilationDatabase.h:140</i>
	 */
	ClangLibrary.CXString.ByValue clang_CompileCommand_getMappedSourceContent(Pointer CXCompileCommand1, int I);
	public static class CXTranslationUnit extends PointerType {
		public CXTranslationUnit(Pointer address) {
			super(address);
		}
		public CXTranslationUnit() {
			super();
		}
	};
	public static class CXModuleMapDescriptor extends PointerType {
		public CXModuleMapDescriptor(Pointer address) {
			super(address);
		}
		public CXModuleMapDescriptor() {
			super();
		}
	};
	public static class CXVirtualFileOverlay extends PointerType {
		public CXVirtualFileOverlay(Pointer address) {
			super(address);
		}
		public CXVirtualFileOverlay() {
			super();
		}
	};
	public static class CXIdxObjCPropertyDeclInfo extends PointerType {
		public CXIdxObjCPropertyDeclInfo(Pointer address) {
			super(address);
		}
		public CXIdxObjCPropertyDeclInfo() {
			super();
		}
	};
	public static class CXCursorSet extends PointerType {
		public CXCursorSet(Pointer address) {
			super(address);
		}
		public CXCursorSet() {
			super();
		}
	};
}
